
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mvpy.estimators package &#8212; MVPy</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/colors.css?v=cc94ab7d" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/custom.css?v=eec3fc85" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'source/mvpy.estimators';</script>
    <script src="../_static/scripts/dropdown.js?v=5b9cef8c"></script>
    <script src="../_static/scripts/version-switcher.js?v=6ebe4089"></script>
    <script src="../_static/scripts/sg_plotly_resize.js?v=dc4a1e18"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/mvpy-icon.png" class="logo__image only-light" alt=""/>
    <img src="../_static/mvpy-icon.png" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">MVPy</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/FabulousFabs/mvpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/FabulousFabs/mvpy" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mvpy.crossvalidation.html">mvpy.crossvalidation package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.dataset.html">mvpy.dataset package</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">mvpy.estimators package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.math.html">mvpy.math package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.preprocessing.html">mvpy.preprocessing package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.signal.html">mvpy.signal package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.utilities.html">mvpy.utilities package</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">mvpy.estimators package</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="mvpy-estimators-package">
<h1>mvpy.estimators package<a class="headerlink" href="#mvpy-estimators-package" title="Link to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">#</a></h2>
</section>
<section id="module-mvpy.estimators.b2b">
<span id="mvpy-estimators-b2b-module"></span><h2>mvpy.estimators.b2b module<a class="headerlink" href="#module-mvpy.estimators.b2b" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding and disentangling features using back2back regression.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.b2b.</span></span><span class="sig-name descname"><span class="pre">B2B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/b2b.py#L346"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.b2b.B2B" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a back-to-back regression to disentangle causal contributions of correlated features.</p>
<p>The back-to-back estimator is a two-step estimator that consists of a decoder and an encoder. 
Effectively, the idea is to split the data <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(y\)</span> into two folds, decode all 
features in fold a, then use predictions from the decoder to encode all true features from all 
predictions in fold b. Consequently, this allows us to obtain a disentangled estimate of the 
causal contribution of each feature.</p>
<p>In practice, this is implemented as:</p>
<div class="math notranslate nohighlight">
\[\hat{G} = (Y^T Y + \alpha_Y)^{-1}Y^T X\]</div>
<div class="math notranslate nohighlight">
\[\hat{H} = (X^T X + \alpha_X)^{-1}X^T Y\hat{G}\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{G}\)</span> is the decoder and <span class="math notranslate nohighlight">\(\hat{H}\)</span> is the encoder, and <span class="math notranslate nohighlight">\(\alpha\)</span> 
are regularisation parameters. Consequently, the diagonal of <span class="math notranslate nohighlight">\(\hat{H}\)</span> contains the 
estimated causal contributions of our features.</p>
<p>For more information on B2B regression, please see <a class="reference internal" href="#rc97a929cd37f-1" id="id1">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">torch.Tensor | np.ndarray, default=torch.tensor([1])</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use a different penalty for each target.</p>
</dd>
<dt><strong>normalise_decoder</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise decoder ouputs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">torch.Tensor | np.ndarray</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool</span></dt><dd><p>Whether to normalise the data</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool</span></dt><dd><p>Whether to use a different penalty for each target.</p>
</dd>
<dt><strong>normalise_decoder</strong><span class="classifier">bool</span></dt><dd><p>Whether to normalise decoder ouputs.</p>
</dd>
<dt><strong>decoder_</strong><span class="classifier">mvpy.estimators.RidgeDecoder</span></dt><dd><p>The decoder.</p>
</dd>
<dt><strong>encoder_</strong><span class="classifier">mvpy.estimators.RidgeDecoder</span></dt><dd><p>The encoder.</p>
</dd>
<dt><strong>scaler_</strong><span class="classifier">mvpy.estimators.Scaler</span></dt><dd><p>The scaler.</p>
</dd>
<dt><strong>causal_</strong><span class="classifier">torch.Tensor | np.ndarray</span></dt><dd><p>The causal contribution of each feature of shape <code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code>.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">torch.Tensor | np.ndarray</span></dt><dd><p>The decoded patterns of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.Scaler</span></code></dt><dd><p>If applied, scalers used in this class.</p>
</dd>
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeDecoder.html#mvpy.estimators.RidgeDecoder" title="mvpy.estimators.RidgeDecoder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.RidgeDecoder</span></code></a></dt><dd><p>Ridge decoders used for the two-step procedure here.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When penalising per target by setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">alpha_per_target</span></code>
to <code class="docutils literal notranslate"><span class="pre">True</span></code>, you may want to consider normalising the decoder by also setting 
<code class="xref py py-attr docutils literal notranslate"><span class="pre">normalise_decoder</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>. This is because otherwise 
decoder outputs may live on very different scales, potentially distorting the causal 
estimates per predictor.</p>
<p>Patterns are computed as per <a class="reference internal" href="#rc97a929cd37f-2" id="id2">[2]</a>. However, these patterns are not disentangled and 
may, consequently, be less informative than desired, depending on strength of existing
correlations.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc97a929cd37f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>King, J.R., Charton, F., Lopez-Paz, D., &amp; Oquab, M. (2020). Back-to-back regression: Disentangling the influence of correlated factors from multivariate observations. NeuroImage, 220, 117028. 10.1016/j.neuroimage.2020.117028</p>
</div>
<div class="citation" id="rc97a929cd37f-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">B2B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2b</span> <span class="o">=</span> <span class="n">B2B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2b</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">causal_</span>
<span class="go">tensor([0.4470, 0.4594, 0.0060])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.b2b.B2B" title="mvpy.estimators.b2b.B2B"><span class="pre">B2B</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/b2b.py#L507"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.b2b.B2B.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>b2b</strong><span class="classifier">mvpy.estimators.B2B</span></dt><dd><p>The cloned estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.b2b.B2B" title="mvpy.estimators.b2b.B2B"><span class="pre">B2B</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/b2b.py#L473"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.b2b.B2B.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The neural data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The targets of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>b2b</strong><span class="classifier">mvpy.estimators.B2B</span></dt><dd><p>The fitted estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/b2b.py#L491"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.b2b.B2B.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The neural data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.classifier">
<span id="mvpy-estimators-classifier-module"></span><h2>mvpy.estimators.classifier module<a class="headerlink" href="#module-mvpy.estimators.classifier" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding features using ridge classifiers.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.classifier.</span></span><span class="sig-name descname"><span class="pre">Classifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OvR'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwarguments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L578"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a wrapper for classifiers that handle one-versus-one (OvO) and one-versus-rest (OvR) classification schemes.</p>
<p>While this class is exposed publically, there are few (if any) direct use 
cases for this class. In principle, it exists for other classifiers that
want to handle multi-class cases as OvO or OvR as a wrapper function that
can either be inherited or created as a super class, specifying the desired
estimator (recommended option).</p>
<p>One-versus-rest (<code class="docutils literal notranslate"><span class="pre">OvR</span></code>) classification computes the decision functions over
inputs <span class="math notranslate nohighlight">\(X\)</span> and then takes the maximum value across decision values
to predict the most likely classes <span class="math notranslate nohighlight">\(\hat{y}\)</span>.</p>
<p>One-versus-one (<code class="docutils literal notranslate"><span class="pre">OvO</span></code>) classification computes all decision functions from
binary classifiers (e.g., <span class="math notranslate nohighlight">\(c_0\)</span> vs <span class="math notranslate nohighlight">\(c_1\)</span>, <span class="math notranslate nohighlight">\(c_0\)</span> vs <span class="math notranslate nohighlight">\(c_2\)</span>,
<span class="math notranslate nohighlight">\(c_1\)</span> vs <span class="math notranslate nohighlight">\(c_2\)</span>, …). For each individual classification problem,
the maximum value is recorded as one vote for the winning class. Votes are
then aggregated across all classifiers and the maximum number of votes decides
the most likely classes <span class="math notranslate nohighlight">\(\hat{y}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>estimator</strong><span class="classifier">sklearn.base.BaseEstimator</span></dt><dd><p>The estimator type wrapped by this class.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘OvR’, ‘OvO’}, default=’OvR’</span></dt><dd><p>For multiclass problems, which method should we use? One-versus-one (OvO) or one-versus-rest (OvR)?</p>
</dd>
<dt><strong>arguments</strong><span class="classifier">List[Any], default=[]</span></dt><dd><p>Arguments to pass to the estimator at initialisation.</p>
</dd>
<dt><strong>kwarguments</strong><span class="classifier">Dict[str, Any], default=dict()</span></dt><dd><p>Keyword arguments to pass to the estimator at initialisation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>estimator</strong><span class="classifier">sklearn.base.BaseEstimator</span></dt><dd><p>The estimator type wrapped by this class.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘OvR’, ‘OvO’}, default=’OvR’</span></dt><dd><p>For multiclass problems, which method should we use? One-versus-one (OvO) or one-versus-rest (OvR)?</p>
</dd>
<dt><strong>arguments</strong><span class="classifier">List[Any], default=[]</span></dt><dd><p>Arguments to pass to the estimator at initialisation.</p>
</dd>
<dt><strong>kwarguments</strong><span class="classifier">Dict[str, Any], default=dict()</span></dt><dd><p>Keyword arguments to pass to the estimator at initialisation.</p>
</dd>
<dt><strong>estimators_</strong><span class="classifier">sklearn.base.BaseEstimator | List[sklearn.base.BaseEstimator]</span></dt><dd><p>All instances of the estimator class (only of type list if OvO).</p>
</dd>
<dt><strong>binariser_</strong><span class="classifier">mvpy.estimators.LabelBinariser</span></dt><dd><p>Label binariser used internally.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>If available, coefficients from all classifiers <code class="docutils literal notranslate"><span class="pre">([n_classifiers,]</span> <span class="pre">n_channels,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>If available, intercepts from all classifiers <code class="docutils literal notranslate"><span class="pre">([n_classifiers,]</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>If available, patterns from all classifiers <code class="docutils literal notranslate"><span class="pre">([n_classifiers,]</span> <span class="pre">n_channels,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
<dt><strong>offsets_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Numerical offsets for each feature in outputs, used internally.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeClassifier.html#mvpy.estimators.RidgeClassifier" title="mvpy.estimators.RidgeClassifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.RidgeClassifier</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.estimators.SVC.html#mvpy.estimators.SVC" title="mvpy.estimators.SVC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.SVC</span></code></a></dt><dd><p>Classifiers that use this class as a wrapper.</p>
</dd>
<dt><a class="reference internal" href="../modules/generated/mvpy.preprocessing.LabelBinariser.html#mvpy.preprocessing.LabelBinariser" title="mvpy.preprocessing.LabelBinariser"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.preprocessing.LabelBinariser</span></code></a></dt><dd><p>Label binariser used internally to generated one-hot encodings.</p>
</dd>
</dl>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.classifier.Classifier" title="mvpy.estimators.classifier.Classifier"><span class="pre">Classifier</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L787"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">Classifier</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.classifier.Classifier" title="mvpy.estimators.classifier.Classifier"><span class="pre">Classifier</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L803"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.copy" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">Classifier</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.decision_function">
<span class="sig-name descname"><span class="pre">decision_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L710"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.decision_function" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L692"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The targets of shape <code class="docutils literal notranslate"><span class="pre">(n_samples[,</span> <span class="pre">n_features])</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">mvpy.estimators.Classifier</span></dt><dd><p>The classifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L726"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L742"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Methods that predict the probability of classes are currently
not implemented and will return decision function outputs
instead. This is because probabilities are not trivial to 
compute and require careful calibration, which we will implement
in the future.</p>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L776"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Obtain the estimator with numpy as backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">mvpy.estimators.classifier._Classifier_numpy</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/classifier.py#L765"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Obtain the estimator with torch as backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">mvpy.estimators.classifier._Classifier_torch</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.covariance">
<span id="mvpy-estimators-covariance-module"></span><h2>mvpy.estimators.covariance module<a class="headerlink" href="#module-mvpy.estimators.covariance" title="Link to this heading">#</a></h2>
<p>A collection of estimators for covariance estimation and
pre-whitening of data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.covariance.</span></span><span class="sig-name descname"><span class="pre">Covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ledoitwolf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L817"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements covariance and precision estimation as well as whitening of data.</p>
<p>For covariance estimation, three methods are currently available through
<code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code>:</p>
<ol class="arabic">
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">empirical</span></code></dt><dd><p>This computes the empirical (sample) covariance matrix:</p>
<div class="math notranslate nohighlight">
\[\Sigma = \mathbb{E}\left[(X - \mathbb{E}[X])(X^T - \mathbb{E}[X^T])\right]\]</div>
<p>This is computationally efficient, but produces estimates of the
covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> that may often be unfavourable: Given
small datasets or noisy measurements, <span class="math notranslate nohighlight">\(\Sigma\)</span> may be ill-
conditioned and not positive-definite with eigenvalues that tend
to be systematically pushed towards the tails. In practice, this
can make inversion challenging and hurts out-of-sample generalisation.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ledoitwolf</span></code></dt><dd><p>This computes the LedoitWolf shrinkage estimator:</p>
<div class="math notranslate nohighlight">
\[\hat\Sigma = (1 - \hat{\delta})\Sigma + \hat\delta T\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\delta}\in[0, 1]\)</span> is the data-driven shrinkage 
intensity that minimises the the expected Frobenius-norm risk:</p>
<div class="math notranslate nohighlight">
\[\hat\delta = \min\left\{1, \max\left\{0, \frac{\hat\pi}{\hat\rho}\right\}\right\},\qquad
\hat\rho = \lvert\lvert\Sigma - T\rvert\rvert_F^2,\qquad
\hat\pi = \frac{1}{n}\sum_{k=1}^{n}\lvert\lvert x_k x_k^T - \Sigma\rvert\rvert_F^2\]</div>
<p>and where:</p>
<div class="math notranslate nohighlight">
\[T = \mu I_p,\qquad \mu = \frac{1}{p}\textrm{tr}(\Sigma)\]</div>
<p>This produces estimates that are well-conditioned and positive-definite. 
For more information on this procedure, please see <a class="reference internal" href="#rbf5e5ef496d8-1" id="id5">[1]</a>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">oas</span></code></dt><dd><p>This computes the oracle approximating shrinkage estimator:</p>
<div class="math notranslate nohighlight">
\[\hat\Sigma = (1 - \hat{\delta})\Sigma + \hat\delta T\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\delta}\in[0, 1]\)</span> is the data-driven shrinkage:</p>
<div class="math notranslate nohighlight">
\[\hat\delta = \frac{(1 - \frac{2}{p}) \textrm{tr}(\Sigma^2) + \textrm{tr}(\Sigma)^2}{(n + 1 - \frac{2}{p})\left(\textrm{tr}(\Sigma^2) - \frac{\textrm{tr}(\Sigma)^2}{p}\right)},\qquad
T = \mu I_p,\qquad \mu = \frac{1}{p}\textrm{tr}(\Sigma)\]</div>
<p>Like <code class="docutils literal notranslate"><span class="pre">ledoitwolf</span></code>, this procedure produces estimates that are
well-conditioned and positive-definite. Contrary to <code class="docutils literal notranslate"><span class="pre">ledoitwolf</span></code>,
shrinkage tends to be more aggressive in this procedure. For more 
information, please see <a class="reference internal" href="#rbf5e5ef496d8-2" id="id6">[2]</a>.</p>
</dd>
</dl>
</li>
</ol>
<p>When calling transform on this class, data will automatically be
whitened based on the estimated covariance matrix. The whitening
matrix is computed from the eigendecomposition as follows:</p>
<div class="math notranslate nohighlight">
\[\Sigma = Q\Lambda Q^T,\qquad 
\Lambda = \textrm{diag}(\lambda_1, ..., \lambda_p) \geq 0,\qquad
W = Q\Lambda^{-\frac{1}{2}}Q^T\]</div>
<p>For more information on whitening, refer to <a class="reference internal" href="#rbf5e5ef496d8-3" id="id7">[3]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">{‘empirical’, ‘ledoitwolf’, ‘oas’}, default = ‘ledoitwolf’</span></dt><dd><p>Which method should be applied for estimation of covariance?</p>
</dd>
<dt><strong>s_min</strong><span class="classifier">float, default = None</span></dt><dd><p>What’s the minimum sample we should consider in the time dimension?</p>
</dd>
<dt><strong>s_max</strong><span class="classifier">float, default = None</span></dt><dd><p>What’s the maximum sample we should consider in the time dimension?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>covariance_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Covariance matrix</p>
</dd>
<dt><strong>precision_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Precision matrix (inverse of covariance matrix)</p>
</dd>
<dt><strong>whitener_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Whitening matrix</p>
</dd>
<dt><strong>shrinkage_</strong><span class="classifier">float, default=None</span></dt><dd><p>Shrinkage parameter, if used by method.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This class assumes features to be the second to last dimension of the data, unless 
there are only two dimensions (in which case it is assumed to be the last dimension).</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rbf5e5ef496d8-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>Ledoit, O., &amp; Wolf, M. (2004). A well-conditioned estimator for large-dimensional covariance matrices. Journal of Multivariate Analysis, 88, 365-411. 10.1016/S0047-259X(03)00096-4</p>
</div>
<div class="citation" id="rbf5e5ef496d8-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">2</a><span class="fn-bracket">]</span></span>
<p>Chen, Y., Wiesel, A., Eldar, Y.C., &amp; Hero, A.O. (2009). Shrinkage algorithms for MMSE covariance estimation. arXiv. 10.48550/arXiv.0907.4698</p>
</div>
<div class="citation" id="rbf5e5ef496d8-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">3</a><span class="fn-bracket">]</span></span>
<p>Kessy, A., Lewin, A., &amp; Strimmer, K. (2016). Optimal whitening and decorrelation. arXiv. 10.48550/arXiv.1512.00809</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Covariance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">s_max</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span><span class="o">.</span><span class="n">covariance_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 10])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance"><span class="pre">Covariance</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L1047"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.clone" title="Link to this definition">#</a></dt>
<dd><p>Obtain a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cov</strong><span class="classifier">mvpy.estimators.Covariance</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance"><span class="pre">Covariance</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L972"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the covariance estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Data to fit the estimator on of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments to pass to the estimator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">Covariance</span></dt><dd><p>Fitted covariance estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L1007"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit the covariance estimator and whiten the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Data to fit the estimator on and transform of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments to pass to the estimator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Whitened data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L1036"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Create the numpy estimator. Note that this function cannot be used for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cov</strong><span class="classifier">mvpy.estimators.Covariance</span></dt><dd><p>The numpy estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L1025"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Create the torch estimator. Note that this function cannot be used for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cov</strong><span class="classifier">mvpy.estimators.Covariance</span></dt><dd><p>The torch estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/covariance.py#L990"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.transform" title="Link to this definition">#</a></dt>
<dd><p>Whiten data using the fitted covariance estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Data to transform of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments to pass to the estimator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Whitened data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.csp">
<span id="mvpy-estimators-csp-module"></span><h2>mvpy.estimators.csp module<a class="headerlink" href="#module-mvpy.estimators.csp" title="Link to this heading">#</a></h2>
<p>A collection of estimators for common spatial patterns.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.csp.CSP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.csp.</span></span><span class="sig-name descname"><span class="pre">CSP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/csp.py#L181"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.csp.CSP" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a simple linear ridge decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">Union[torch.Tensor, np.ndarray]</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use a different penalty for each target.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>estimator_</strong><span class="classifier">mvpy.estimators.RidgeCV</span></dt><dd><p>The ridge estimator.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">Union[torch.Tensor, np.ndarray]</span></dt><dd><p>The decoded pattern.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">Union[torch.Tensor, np.ndarray]</span></dt><dd><p>The coefficeints of the decoder.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">Union[torch.Tensor, np.ndarray]</span></dt><dd><p>The intercepts of the decoder.</p>
</dd>
<dt><strong>alpha_</strong><span class="classifier">Union[torch.Tensor, np.ndarray]</span></dt><dd><p>The penalties used for estimation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>After fitting the decoder, this class will also estimate the decoded patterns. This follows the approach detailed in <a class="reference internal" href="#r9fe945d61306-4" id="id11">[4]</a>. Please also be aware that, while this class supports decoding multiple features at once, these will principally be separate regressions wherein individual contributions are not disentangled. If you would like to do this, please consider using a back-to-back decoder.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r9fe945d61306-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">4</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">pattern_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([60, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.size([100, 5])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.csp.CSP.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/csp.py#L290"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.csp.CSP.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Decoder</dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.csp.CSP.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/csp.py#L261"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.csp.CSP.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The targets.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.csp.CSP.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/csp.py#L274"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.csp.CSP.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>The predictions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
<p>Python part of the warnings subsystem.</p>
</section>
<section id="module-mvpy.estimators.kernelridgecv">
<span id="mvpy-estimators-kernelridgecv-module"></span><h2>mvpy.estimators.kernelridgecv module<a class="headerlink" href="#module-mvpy.estimators.kernelridgecv" title="Link to this heading">#</a></h2>
<p>A collection of estimators for fitting cross-validated ridge regressions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.kernelridgecv.KernelRidgeCV">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.kernelridgecv.</span></span><span class="sig-name descname"><span class="pre">KernelRidgeCV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coef0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_per_target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/kernelridgecv.py#L570"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a kernel ridge regression with cross-validation.</p>
<p>Kernel ridge regression maps input data <span class="math notranslate nohighlight">\(X\)</span> to output data <span class="math notranslate nohighlight">\(y\)</span>
through coefficients <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<div class="math notranslate nohighlight">
\[y = \beta\kappa + \varepsilon\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa\)</span> is some gram matrix of <span class="math notranslate nohighlight">\(X\)</span> and solves for the model 
<span class="math notranslate nohighlight">\(\beta\)</span> through:</p>
<div class="math notranslate nohighlight">
\[\arg\min_\beta \frac{1}{2}\lvert\lvert y - \kappa\beta\rvert\rvert_2^2 + \frac{\alpha_\beta}{2}\lvert\lvert\beta\rvert\rvert_\kappa^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_\beta\)</span> are penalties to test in LOO-CV which has a 
convenient closed-form solution here:</p>
<div class="math notranslate nohighlight">
\[\arg\min_{\alpha_\beta} \frac{1}{N} \sum_{i = 1}^{N} \left(\frac{y - \kappa\beta_\alpha}{1 - H_{\alpha,ii}}\right) \qquad\textrm{where}\qquad
H_{\alpha,ii} = \textrm{diag}\left(\kappa\cdot\left(\kappa + \alpha_\beta I\right)^{-1}\right)\]</div>
<p>In other words, this solves a ridge regression in the parameter space defined by 
the kernel function <span class="math notranslate nohighlight">\(\kappa(X, X)\)</span>. This is convenient because, just like
<a class="reference internal" href="../modules/generated/mvpy.estimators.SVC.html#mvpy.estimators.SVC" title="mvpy.estimators.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">SVC</span></code></a>, it allows for non-parametric estimation. For
example, <code class="xref py py-attr docutils literal notranslate"><span class="pre">kernel</span></code> <code class="docutils literal notranslate"><span class="pre">rbf</span></code> may capture
non-linearities in data that <a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a> cannot account
for. The closed-form LOO-CV formula is evaluated at all values of 
<code class="xref py py-attr docutils literal notranslate"><span class="pre">alphas</span></code> and the penalty minimising the
mean-squared loss is automatically chosen. This is convenient because it is 
faster than performing inner cross-validation to fine-tune penalties.</p>
<p>As such, <a class="reference internal" href="../modules/generated/mvpy.estimators.KernelRidgeCV.html#mvpy.estimators.KernelRidgeCV" title="mvpy.estimators.KernelRidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">KernelRidgeCV</span></code></a> mirrors <a class="reference internal" href="../modules/generated/mvpy.estimators.SVC.html#mvpy.estimators.SVC" title="mvpy.estimators.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">SVC</span></code></a>
in its application of the kernel trick and the associated benefits. The key 
difference here is that <a class="reference internal" href="../modules/generated/mvpy.estimators.KernelRidgeCV.html#mvpy.estimators.KernelRidgeCV" title="mvpy.estimators.KernelRidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">KernelRidgeCV</span></code></a> is fit
using L2 regularised squared error, whereas <a class="reference internal" href="../modules/generated/mvpy.estimators.SVC.html#mvpy.estimators.SVC" title="mvpy.estimators.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">SVC</span></code></a>
is fit through sequential minimal optimisation or gradient ascent over hinge
losses. In practice, this means that <a class="reference internal" href="../modules/generated/mvpy.estimators.KernelRidgeCV.html#mvpy.estimators.KernelRidgeCV" title="mvpy.estimators.KernelRidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">KernelRidgeCV</span></code></a> 
is much faster–particularly when multiple values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">alphas</span></code> 
are specified–but produces less sparse solutions that are not margin-based.</p>
<p>For more information on kernel ridge regression, see <a class="reference internal" href="#rdb21b996cf2a-1" id="id13">[1]</a> <a class="reference internal" href="#rdb21b996cf2a-2" id="id14">[2]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.tensor | List | float | int, default=1.0</span></dt><dd><p>Alpha penalties to test.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’}, default=’linear’</span></dt><dd><p>Kernel function to use.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">{float, ‘auto’, ‘scale’}, default=’auto’</span></dt><dd><p>Gamma to use in kernel computation.</p>
</dd>
<dt><strong>coef0</strong><span class="classifier">float, default=1.0</span></dt><dd><p>Coefficient zero to use in kernel computation.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">float, default=3.0</span></dt><dd><p>Degree of kernel to use.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Should we fit one alpha per target?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.tensor | List | float | int, default=1.0</span></dt><dd><p>Alpha penalties to test.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’}, default=’linear’</span></dt><dd><p>Kernel function to use.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">{float, ‘auto’, ‘scale’}, default=’auto’</span></dt><dd><p>Gamma to use in kernel computation.</p>
</dd>
<dt><strong>coef0</strong><span class="classifier">float, default=1.0</span></dt><dd><p>Coefficient zero to use in kernel computation.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">float, default=3.0</span></dt><dd><p>Degree of kernel to use.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Should we fit one alpha per target?</p>
</dd>
<dt><strong>X_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Training data X of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>A_dual_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Chosen dual alpha of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
<dt><strong>alpha_</strong><span class="classifier">float | np.ndarray | torch.Tensor</span></dt><dd><p>Chosen alpha penalties.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">Optional[np.ndarray | torch.Tensor]</span></dt><dd><p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">kernel</span></code> is <code class="docutils literal notranslate"><span class="pre">linear</span></code>, coefficients of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.RidgeCV</span></code></a></dt><dd><p>Alternative ridge regression without kernel functions.</p>
</dd>
<dt><a class="reference internal" href="mvpy.math.html#module-mvpy.math.kernel_linear" title="mvpy.math.kernel_linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.kernel_linear</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.kernel_poly" title="mvpy.math.kernel_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.kernel_poly</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.kernel_rbf" title="mvpy.math.kernel_rbf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.kernel_rbf</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.kernel_sigmoid" title="mvpy.math.kernel_sigmoid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.kernel_sigmoid</span></code></a></dt><dd><p>Available kernel functions.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Coefficients <code class="xref py py-attr docutils literal notranslate"><span class="pre">coef_</span></code> are available 
only when <code class="xref py py-attr docutils literal notranslate"><span class="pre">kernel</span></code> is <code class="docutils literal notranslate"><span class="pre">linear</span></code>
where primal weights can be computed from dual solutions:</p>
<div class="math notranslate nohighlight">
\[w = X^T\beta\]</div>
<p>For other kernel functions, coefficients are not interpretable and,
therefore, not computed here.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For small values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">alphas</span></code>, kernel
matrices may no longer be positive semidefinite. This means that, in many
cases, model fitting may have to resort to least squares solutions, which
can decrease through-put by an order of magnitude (or more). This issue
is particularly prevalent in the numpy backend. Please consider this when
choosing penalties.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This issue can also appear independently of <code class="xref py py-attr docutils literal notranslate"><span class="pre">alphas</span></code>.
For example, the gram matrix given <span class="math notranslate nohighlight">\(X\sim\mathcal{N}(0, 1)\)</span> will already
be rank-deficient if <span class="math notranslate nohighlight">\(n\_samples\geq n\_channels\)</span>. As is the case in <code class="docutils literal notranslate"><span class="pre">sklearn</span></code>,
this will lead to poor solving speed in the numpy backend. The torch backend
is more robust to this. Please consider this when investigating your data
prior to model fitting.</p>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdb21b996cf2a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">1</a><span class="fn-bracket">]</span></span>
<p>Murphy, K.P. (2012). Machine learning: A probabilistic perspective. MIT Press.</p>
</div>
<div class="citation" id="rdb21b996cf2a-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">2</a><span class="fn-bracket">]</span></span>
<p>Nadaraya, E.A. (1964). On estimating regression. Theory of Probability and Its Applications, 9, 141-142. 10.1137/1109020</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">KernelRidgeCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ß</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">KernelRidgeCV</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">coef_</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.kernelridgecv.KernelRidgeCV.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV" title="mvpy.estimators.kernelridgecv.KernelRidgeCV"><span class="pre">KernelRidgeCV</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/kernelridgecv.py#L777"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.clone" title="Link to this definition">#</a></dt>
<dd><p>Make a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>estimator</strong><span class="classifier">KernelRidgeCV</span></dt><dd><p>A clone of this class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.kernelridgecv.KernelRidgeCV.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV" title="mvpy.estimators.kernelridgecv.KernelRidgeCV"><span class="pre">KernelRidgeCV</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/kernelridgecv.py#L743"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input features of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>estimator</strong><span class="classifier">KernelRidgeCV</span></dt><dd><p>The fitted estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.kernelridgecv.KernelRidgeCV.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/kernelridgecv.py#L761"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.predict" title="Link to this definition">#</a></dt>
<dd><p>Make predictions from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Predicted output features of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
<p>Python part of the warnings subsystem.</p>
</section>
<section id="module-mvpy.estimators.receptivefield">
<span id="mvpy-estimators-receptivefield-module"></span><h2>mvpy.estimators.receptivefield module<a class="headerlink" href="#module-mvpy.estimators.receptivefield" title="Link to this heading">#</a></h2>
<p>A collection of estimators for ReceptiveField modeling (mTRF + SR).</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.receptivefield.ReceptiveField">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.receptivefield.</span></span><span class="sig-name descname"><span class="pre">ReceptiveField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ridge'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg_cv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patterns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_intercept</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_correction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/receptivefield.py#L1490"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.receptivefield.ReceptiveField" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements receptive field estimation (for multivariate temporal response functions or stimulus reconstruction).</p>
<p>Generally, mTRF models are described by:</p>
<div class="math notranslate nohighlight">
\[r(t,n) = \sum_{\tau} w(\tau, n) s(t - \tau) + \varepsilon\]</div>
<p>where <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the reconstructed signal at timepoint <span class="math notranslate nohighlight">\(t\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(s(t)\)</span> 
is the stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(w(\tau, n)\)</span> is the weight at time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel 
<span class="math notranslate nohighlight">\(n\)</span>, and <span class="math notranslate nohighlight">\(\varepsilon\)</span> is the error.</p>
<p>SR models are estimated as:</p>
<div class="math notranslate nohighlight">
\[s(t) = \sum_{n}\sum_{\tau} r(t + \tau, n) g(\tau, n)\]</div>
<p>where <span class="math notranslate nohighlight">\(s(t)\)</span> is the reconstructed stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the neural response
at <span class="math notranslate nohighlight">\(t\)</span> and lagged by <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(g(\tau, n)\)</span> is the weight at 
time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>For more information on mTRF or SR models, see <a class="reference internal" href="#r446d4aa1b115-1" id="id17">[1]</a>.</p>
<p>Consequently, this class fundamentally solves the same problem as <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>.
However, unlike <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>, this approach avoids creating and solving the
full time-delayed design and outcome matrix. Instead, this approach uses the fact that we are fundamentally
interested in (de-)convolution, which can be solved efficiently through estimation of auto- and cross-
correlations in the Fourier domain. For more information on this approach, see <a class="reference internal" href="#r446d4aa1b115-2" id="id18">[2]</a> <a class="reference internal" href="#r446d4aa1b115-3" id="id19">[3]</a> <a class="reference internal" href="#r446d4aa1b115-4" id="id20">[4]</a>.</p>
<p>Solving this in the Fourier domain can be extremely beneficial when the number of predictors <code class="docutils literal notranslate"><span class="pre">n_features</span></code>
is small, but scales poorly for a higher number of <code class="docutils literal notranslate"><span class="pre">n_features</span></code> unless 
<code class="xref py py-attr docutils literal notranslate"><span class="pre">edge_correction</span></code> is explicitly disabled. Generally, we would
recommend testing both <a class="reference internal" href="../modules/generated/mvpy.estimators.ReceptiveField.html#mvpy.estimators.ReceptiveField" title="mvpy.estimators.ReceptiveField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceptiveField</span></code></a> and <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>
on a realistic subset of the data before deciding for one of the two approaches.</p>
<p>Like <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>, this class will automatically perform inner cross-validation
if multiple values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">alpha</span></code> are supplied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t_min</strong><span class="classifier">float</span></dt><dd><p>Minimum time point to fit (unlike TimeDelayed, this is relative to y).</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float</span></dt><dd><p>Maximum time point to fit (unlike TimeDelayed, this is relative to y). Must be greater than t_min.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>Sampling frequency.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">int | float | np.ndarray | torch.Tensor | List, default=1.0</span></dt><dd><p>Alpha penalties as float or of shape (n_penalties,). If not float, cross-validation will be employed (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">reg_cv</span></code>).</p>
</dd>
<dt><strong>reg_type</strong><span class="classifier">{‘ridge’, ‘laplacian’, List}, default=’ridge’</span></dt><dd><p>Type of regularisation to employ (either ‘ridge’ or ‘laplacian’ or tuple describing <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">features)</span></code>).</p>
</dd>
<dt><strong>reg_cv</strong><span class="classifier">{int, ‘LOO’, mvpy.crossvalidation.KFold}, default=5</span></dt><dd><p>If alpha is list or array, what cross-validation scheme should we use? Integers are interpeted as <code class="xref py py-attr docutils literal notranslate"><span class="pre">n_splits</span></code> for <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.KFold.html#mvpy.crossvalidation.KFold" title="mvpy.crossvalidation.KFold"><code class="xref py py-class docutils literal notranslate"><span class="pre">KFold</span></code></a>. String input <code class="docutils literal notranslate"><span class="pre">'LOO'</span></code> will use <a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a> to solve LOO-CV over alphas, but is available only for <code class="xref py py-attr docutils literal notranslate"><span class="pre">reg_type</span></code> <code class="docutils literal notranslate"><span class="pre">'ridge'</span></code>. Alternatively, a cross-validator that exposes a <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.KFold.html#mvpy.crossvalidation.KFold.split" title="mvpy.crossvalidation.KFold.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method can be supplied.</p>
</dd>
<dt><strong>patterns</strong><span class="classifier">bool, default=False</span></dt><dd><p>Should we estimate the patterns from coefficients and data (useful only for stimulus reconstruction, not mTRF)?</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Should we fit an intercept for this model?</p>
</dd>
<dt><strong>edge_correction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Should we apply edge corrections to auto-correlations?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t_min</strong><span class="classifier">float</span></dt><dd><p>Minimum time point to fit (unlike TimeDelayed, this is relative to y).</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float</span></dt><dd><p>Maximum time point to fit (unlike TimeDelayed, this is relative to y). Must be greater than t_min.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>Sampling frequency.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">int | float | np.ndarray | torch.Tensor | List, default=1.0</span></dt><dd><p>Alpha penalties as float or of shape <code class="docutils literal notranslate"><span class="pre">(n_penalties,)</span></code>. If not float, cross-validation will be employed (see <code class="xref py py-attr docutils literal notranslate"><span class="pre">reg_cv</span></code>).</p>
</dd>
<dt><strong>reg_type</strong><span class="classifier">{‘ridge’, ‘laplacian’, List}, default=’ridge’</span></dt><dd><p>Type of regularisation to employ (either ‘ridge’ or ‘laplacian’ or tuple describing <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">features)</span></code>).</p>
</dd>
<dt><strong>reg_cv</strong><span class="classifier">{int, ‘LOO’, mvpy.crossvalidation.KFold}, default=5</span></dt><dd><p>If alpha is list or array, what cross-validation scheme should we use? Integers are interpeted as <code class="xref py py-attr docutils literal notranslate"><span class="pre">n_splits</span></code> for <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.KFold.html#mvpy.crossvalidation.KFold" title="mvpy.crossvalidation.KFold"><code class="xref py py-class docutils literal notranslate"><span class="pre">KFold</span></code></a>. String input <code class="docutils literal notranslate"><span class="pre">'LOO'</span></code> will use <a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a> to solve LOO-CV over alphas, but is available only for <code class="xref py py-attr docutils literal notranslate"><span class="pre">reg_type</span></code> <code class="docutils literal notranslate"><span class="pre">'ridge'</span></code>. Alternatively, a cross-validator that exposes a <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.KFold.html#mvpy.crossvalidation.KFold.split" title="mvpy.crossvalidation.KFold.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a> method can be supplied.</p>
</dd>
<dt><strong>patterns</strong><span class="classifier">bool, default=False</span></dt><dd><p>Should we estimate the patterns from coefficients and data (useful only for stimulus reconstruction, not mTRF)?</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Should we fit an intercept for this model?</p>
</dd>
<dt><strong>edge_correction</strong><span class="classifier">bool, default=True</span></dt><dd><p>Should we apply edge corrections to auto-correlations?</p>
</dd>
<dt><strong>s_min</strong><span class="classifier">int</span></dt><dd><p>t_min converted to samples.</p>
</dd>
<dt><strong>s_max</strong><span class="classifier">int</span></dt><dd><p>t_max converted to samples.</p>
</dd>
<dt><strong>window</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The TRF window ranging from s_min-s_max of shape <code class="docutils literal notranslate"><span class="pre">(n_trf,)</span></code>.</p>
</dd>
<dt><strong>n_features_</strong><span class="classifier">int</span></dt><dd><p>Number of features in <span class="math notranslate nohighlight">\(X\)</span>.</p>
</dd>
<dt><strong>n_channels_</strong><span class="classifier">int</span></dt><dd><p>Number of channels in <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd>
<dt><strong>n_trf_</strong><span class="classifier">int</span></dt><dd><p>Number of timepoints in the estimated response functions.</p>
</dd>
<dt><strong>cov_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Covariance from auto-correlations of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features</span> <span class="pre">*</span> <span class="pre">n_trf,</span> <span class="pre">n_features</span> <span class="pre">*</span> <span class="pre">n_trf)</span></code>.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Estimated coefficients of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features,</span> <span class="pre">n_trf)</span></code>.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>If computed, estimated pattern of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features,</span> <span class="pre">n_trf)</span></code>.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">float | np.ndarray | torch.Tensor</span></dt><dd><p>Estimated intercepts of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,)</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.TimeDelayed</span></code></a></dt><dd><p>An alternative mTRF/SR estimator that solves the time-expanded design matrix.</p>
</dd>
<dt><a class="reference internal" href="../modules/generated/mvpy.crossvalidation.KFold.html#mvpy.crossvalidation.KFold" title="mvpy.crossvalidation.KFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.crossvalidation.KFold</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.RepeatedKFold.html#mvpy.crossvalidation.RepeatedKFold" title="mvpy.crossvalidation.RepeatedKFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.crossvalidation.RepeatedKFold</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.StratifiedKFold.html#mvpy.crossvalidation.StratifiedKFold" title="mvpy.crossvalidation.StratifiedKFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.crossvalidation.StratifiedKFold</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.crossvalidation.RepeatedStratifiedKFold.html#mvpy.crossvalidation.RepeatedStratifiedKFold" title="mvpy.crossvalidation.RepeatedStratifiedKFold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.crossvalidation.RepeatedStratifiedKFold</span></code></a></dt><dd><p>Cross-validation classes for automatically testing multiple values of <code class="xref py py-attr docutils literal notranslate"><span class="pre">alpha</span></code>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For SR models it is recommended to also set <code class="xref py py-attr docutils literal notranslate"><span class="pre">patterns</span></code> 
to <code class="docutils literal notranslate"><span class="pre">True</span></code> to estimate not only the coefficients but also the patterns that were actually used for 
reconstructing stimuli. For more information, see <a class="reference internal" href="#r446d4aa1b115-5" id="id21">[5]</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unlike <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>, this class expects <code class="xref py py-attr docutils literal notranslate"><span class="pre">t_min</span></code> 
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">t_max</span></code> to be causal in <span class="math notranslate nohighlight">\(y\)</span>. Consequently,
positive values mean <span class="math notranslate nohighlight">\(X(t)\)</span> asserts influence over <span class="math notranslate nohighlight">\(y(t + \tau)\)</span>. This is in 
line with MNE’s behaviour.</p>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r446d4aa1b115-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">1</a><span class="fn-bracket">]</span></span>
<p>Crosse, M.J., Di Liberto, G.M., Bednar, A., &amp; Lalor, E.C. (2016). The multivariate temporal response function (mTRF) toolbox: A MATLAB toolbox for relating neural signals to continuous stimuli. Frontiers in Human Neuroscience, 10, 604. 10.3389/fnhum.2016.00604</p>
</div>
<div class="citation" id="r446d4aa1b115-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">2</a><span class="fn-bracket">]</span></span>
<p>Willmore, B., &amp; Smyth, D. (2009). Methods for first-order kernel estimation: Simple-cell receptive fields from responses to natural scenes. Network: Computation in Neural Systems, 14, 553-577. 10.1088/0954-898X_14_3_309</p>
</div>
<div class="citation" id="r446d4aa1b115-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">3</a><span class="fn-bracket">]</span></span>
<p>Theunissen, F.E., David, S.V., Singh, N.C., Hsu, A., Vinje, W.E., &amp; Gallant, J.L. (2001). Estimating spatio-temporal receptive fields of auditory and visual neurons from their responses to natural stimuli. Network: Computation in Neural Systems, 12, 289-316. 10.1080/net.12.3.289.316</p>
</div>
<div class="citation" id="r446d4aa1b115-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://mne.tools/stable/generated/mne.decoding.ReceptiveField.html">https://mne.tools/stable/generated/mne.decoding.ReceptiveField.html</a></p>
</div>
<div class="citation" id="r446d4aa1b115-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">5</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>For mTRF estimation, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReceptiveField</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span> <span class="o">=</span> <span class="n">ReceptiveField</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coef_</span>
<span class="go">tensor([[[0.9912, 2.0055, 2.9974, 1.9930, 0.9842]]])</span>
</pre></div>
</div>
<p>For stimulus reconstruction, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReceptiveField</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">50</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">ReceptiveField</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">patterns</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="go">tensor([ 0.2148,  0.7017,  1.4021,  2.3925,  3.5046,  4.4022,  5.4741,  6.4759,</span>
<span class="go">         7.5530,  8.4915,  9.6014,  10.5186, 11.5872, 12.6197, 13.5862, 14.6769,</span>
<span class="go">         15.6523, 16.6765, 17.6622, 18.7172, 19.7117, 20.7994, 21.7023, 22.7885,</span>
<span class="go">         23.8434, 24.7849, 25.8697, 26.8705, 27.8523, 28.9028, 29.9428, 30.9342,</span>
<span class="go">         31.9401, 32.9729, 33.9704, 34.9847, 36.0325, 37.0251, 38.0297, 39.0678,</span>
<span class="go">         40.0847, 41.0827, 42.1410, 43.0924, 44.2115, 45.1548, 41.9511, 45.9482,</span>
<span class="go">         32.2861, 76.4690])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.receptivefield.ReceptiveField.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.receptivefield.ReceptiveField" title="mvpy.estimators.receptivefield.ReceptiveField"><span class="pre">ReceptiveField</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/receptivefield.py#L1700"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.receptivefield.ReceptiveField.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator, optionally with cross-validation over penalties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rf</strong><span class="classifier">mvpy.estimators._ReceptiveField_numpy | mvpy.estimators._ReceptiveField_torch</span></dt><dd><p>The fitted ReceptiveField estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.receptivefield.ReceptiveField.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/receptivefield.py#L1718"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.receptivefield.ReceptiveField.predict" title="Link to this definition">#</a></dt>
<dd><p>Make predictions from model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Predicted responses of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Exposes decorators for compilation.</p>
<p>This module provides access to the mathematical functions</p>
<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.ridgeclassifier">
<span id="mvpy-estimators-ridgeclassifier-module"></span><h2>mvpy.estimators.ridgeclassifier module<a class="headerlink" href="#module-mvpy.estimators.ridgeclassifier" title="Link to this heading">#</a></h2>
<p>A collection of estimators for ridge classification.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.ridgeclassifier.</span></span><span class="sig-name descname"><span class="pre">RidgeClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OvR'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_intercept</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_per_target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L407"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a linear ridge classifier.</p>
<p>Ridge classifiers effectively frame a classification problem as a simple
linear ridge regression, mapping from neural data <span class="math notranslate nohighlight">\(X\)</span> to labels
<span class="math notranslate nohighlight">\(y\)</span> through spatial filters <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<div class="math notranslate nohighlight">
\[y = \beta X + \varepsilon\quad\textrm{where}\quad y\in\{-1, 1\}\]</div>
<p>Consequently, we solve for spatial filters through:</p>
<div class="math notranslate nohighlight">
\[\arg\min_{\beta} \sum_{i}(y_i - \beta^TX_i)^2 + \alpha_\beta\lvert\lvert\beta\rvert\rvert^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_\beta\)</span> are the penalties to test in LOO-CV.</p>
<p>This linear filter estimation is extremely convenient for neural decoding 
because, unlike other decoding approaches such as <a class="reference internal" href="../modules/generated/mvpy.estimators.SVC.html#mvpy.estimators.SVC" title="mvpy.estimators.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">SVC</span></code></a>,
this can be solved extremely efficiently and, for many decoding tasks,
will perform well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to fit individual alphas per target.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to fit individual alphas per target.</p>
</dd>
<dt><strong>estimator</strong><span class="classifier">mvpy.estimators.RidgeDecoder</span></dt><dd><p>The ridge estimator.</p>
</dd>
<dt><strong>binariser_</strong><span class="classifier">mvpy.preprocessing.LabelBinariser</span></dt><dd><p>The label binariser used internally.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The intercepts of the classifier.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The coefficients of the classifier.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The patterns of the classifier.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default, this will not allow alpha values to differ between targets. In certain situations, 
this may be desirable, however. In the multi-class case, it should be carefully evaluated
whether or not <code class="xref py py-attr docutils literal notranslate"><span class="pre">alpha_per_target</span></code> should be enabled,
as here it may also hurt decoding performance if penalties are on different scales and 
<code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code> is <code class="docutils literal notranslate"><span class="pre">OvR</span></code>.</p>
<p>Coefficients are transformed to patterns to facilitate interpretation thereof. For more 
information, please see <a class="reference internal" href="#rdea6507f1e04-1" id="id27">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdea6507f1e04-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id27">1</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We can either do classification over a single feature, like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">RidgeClassifier</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_h</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y_h</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">y</span><span class="p">)</span>
<span class="go">tensor(0.8533)</span>
</pre></div>
</div>
<p>Or we can also do classification over multiple features, like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_classification</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_classes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_informative</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_classes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n_informative</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">RidgeClassifier</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_h</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y_h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">torch.tensor([0.82, 0.75])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier" title="mvpy.estimators.ridgeclassifier.RidgeClassifier"><span class="pre">RidgeClassifier</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L630"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">RidgeClassifier</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier" title="mvpy.estimators.ridgeclassifier.RidgeClassifier"><span class="pre">RidgeClassifier</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L641"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.copy" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">RidgeClassifier</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.decision_function">
<span class="sig-name descname"><span class="pre">decision_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L575"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.decision_function" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L557"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The targets of shape <code class="docutils literal notranslate"><span class="pre">(n_samples[,</span> <span class="pre">n_features])</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">Classifier</span></dt><dd><p>The classifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L591"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features (n_samples, n_channels).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeclassifier.RidgeClassifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeclassifier.py#L607"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_classes)</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Methods that predict the probability of classes are currently
not implemented and will return decision function outputs
instead. This is because probabilities are not trivial to 
compute and require careful calibration, which we will implement
in the future.</p>
</div>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.ridgecv">
<span id="mvpy-estimators-ridgecv-module"></span><h2>mvpy.estimators.ridgecv module<a class="headerlink" href="#module-mvpy.estimators.ridgecv" title="Link to this heading">#</a></h2>
<p>A collection of estimators for fitting cross-validated ridge regressions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.ridgecv.</span></span><span class="sig-name descname"><span class="pre">RidgeCV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_intercept</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_per_target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgecv.py#L219"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements ridge regression with cross-validation.</p>
<p>Ridge regression maps input data <span class="math notranslate nohighlight">\(X\)</span> to output data <span class="math notranslate nohighlight">\(y\)</span> 
through coefficients <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<div class="math notranslate nohighlight">
\[y = \beta X + \varepsilon\]</div>
<p>and solves for the model <span class="math notranslate nohighlight">\(\beta\)</span> through:</p>
<div class="math notranslate nohighlight">
\[\arg\min_\beta \sum_i (y_i - \beta^T X_i)^2 + \alpha_\beta\lvert\lvert\beta\rvert\rvert^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_\beta\)</span> are penalties to test in LOO-CV which 
has a convenient closed-form solution here:</p>
<div class="math notranslate nohighlight">
\[\arg\min_{\alpha_\beta} \frac{1}{N}\sum_{i = 1}^{N} \left(\frac{y - \beta_\alpha X}{1 - H_{\alpha,ii}}\right)\qquad
\textrm{where}\qquad
H_{\alpha,ii} = \textrm{diag}\left(X(X^T X + \alpha I)^{-1}X^T\right)\]</div>
<p>As such, this will automatically evaluate the LOO-CV of all values of 
<code class="xref py py-attr docutils literal notranslate"><span class="pre">alphas</span></code> and chose the penalty that
minimises the mean-squared loss. This is convenient because it is much
faster than performing inner cross-validation to fine-tune penalties.</p>
<p>For more information on ridge regression, see <a class="reference internal" href="#ra1e7d630ceca-1" id="id29">[1]</a>. This implementation
follows <a class="reference internal" href="#ra1e7d630ceca-2" id="id30">[2]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.Tensor | List | float | int, default=1</span></dt><dd><p>Penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to use a different penalty for each target.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alpha_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties used for estimation.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The intercepts of shape <code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code>.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The coefficients of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If data are supplied as numpy, this class will fall back to <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.linear_model.RidgeCV</span></code>. See <a class="reference internal" href="#ra1e7d630ceca-3" id="id31">[3]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="ra1e7d630ceca-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">1</a><span class="fn-bracket">]</span></span>
<p>McDonald, G.C. (2009). Ridge regression. Wiley Interdisciplinary Reviews: Computational Statistics, 1, 93-100. doi.org/10.1002/wics.14</p>
</div>
<div class="citation" id="ra1e7d630ceca-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">2</a><span class="fn-bracket">]</span></span>
<p>King, J.R. (2020). torch_ridge. <a class="github reference external" href="https://github.com/kingjr/torch_ridge">kingjr/torch_ridge</a></p>
</div>
<div class="citation" id="ra1e7d630ceca-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id31">3</a><span class="fn-bracket">]</span></span>
<p>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., … &amp; Vanderplas, J. (2011). Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12, 2825-2830.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ß</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">RidgeCV</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">coef_</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgecv.RidgeCV" title="mvpy.estimators.ridgecv.RidgeCV"><span class="pre">RidgeCV</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgecv.py#L357"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.clone" title="Link to this definition">#</a></dt>
<dd><p>Make a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ridge</strong><span class="classifier">RidgeCV</span></dt><dd><p>A clone of this class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgecv.RidgeCV" title="mvpy.estimators.ridgecv.RidgeCV"><span class="pre">RidgeCV</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgecv.py#L323"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Output data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ridge</strong><span class="classifier">RidgeCV</span></dt><dd><p>The fitted ridge estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgecv.py#L341"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Input data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>Predicted data of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.ridgedecoder">
<span id="mvpy-estimators-ridgedecoder-module"></span><h2>mvpy.estimators.ridgedecoder module<a class="headerlink" href="#module-mvpy.estimators.ridgedecoder" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding features using ridge decoders.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.ridgedecoder.RidgeDecoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.ridgedecoder.</span></span><span class="sig-name descname"><span class="pre">RidgeDecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgedecoder.py#L291"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgedecoder.RidgeDecoder" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a linear ridge decoder.</p>
<p>This decoder maps from neural data <span class="math notranslate nohighlight">\(X\)</span> to features <span class="math notranslate nohighlight">\(y\)</span> 
through spatial filters <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<div class="math notranslate nohighlight">
\[y = \beta X + \varepsilon\]</div>
<p>Consequently, we solve for spatial filters through:</p>
<div class="math notranslate nohighlight">
\[\arg\min_{\beta} \sum_{i} (y_i - \beta^T X_i)^2 + \alpha_\beta \lvert\lvert\beta\rvert\rvert^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_\beta\)</span> are the penalties to test in LOO-CV.</p>
<p>Beyond what <a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a> would also achieve, this class additionally computes
the patterns used for decoding following <a class="reference internal" href="#r230bc9cf8420-1" id="id35">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>fit_intercept</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to fit an intercept.</p>
</dd>
<dt><strong>normalise</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to normalise the data.</p>
</dd>
<dt><strong>alpha_per_target</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use a different penalty for each target.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>estimator_</strong><span class="classifier">mvpy.estimators.RidgeCV</span></dt><dd><p>The ridge estimator.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The decoded pattern of shape <code class="docutils literal notranslate"><span class="pre">(n_channels,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The coefficeints of the decoder of shape <code class="docutils literal notranslate"><span class="pre">(n_features,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The intercepts of the decoder of shape <code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code>.</p>
</dd>
<dt><strong>alpha_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties used for estimation.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.RidgeCV</span></code></a></dt><dd><p>The estimator used for ridge decoding.</p>
</dd>
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.B2B.html#mvpy.estimators.B2B" title="mvpy.estimators.B2B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.B2B</span></code></a></dt><dd><p>An alternative decoding estimator that explicitly disentangles correlated features.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>While this class supports decoding an arbitrary number of features at once, all features will be
treated as individual regressions. Consequently, this class cannot control for correlations among
predictors. If this is desired, refer to <a class="reference internal" href="../modules/generated/mvpy.estimators.B2B.html#mvpy.estimators.B2B" title="mvpy.estimators.B2B"><code class="xref py py-class docutils literal notranslate"><span class="pre">B2B</span></code></a> instead.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r230bc9cf8420-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">1</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeDecoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">RidgeDecoder</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">pattern_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([60, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.size([100, 5])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgedecoder.RidgeDecoder.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgedecoder.RidgeDecoder" title="mvpy.estimators.ridgedecoder.RidgeDecoder"><span class="pre">RidgeDecoder</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgedecoder.py#L425"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decoder</strong><span class="classifier">mvpy.estimators.RidgeDecoder</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgedecoder.RidgeDecoder.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgedecoder.py#L396"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The neural data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgedecoder.RidgeDecoder.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgedecoder.py#L409"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The neural data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.ridgeencoder">
<span id="mvpy-estimators-ridgeencoder-module"></span><h2>mvpy.estimators.ridgeencoder module<a class="headerlink" href="#module-mvpy.estimators.ridgeencoder" title="Link to this heading">#</a></h2>
<p>A collection of estimators for encoding features using ridge regressions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeencoder.RidgeEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.ridgeencoder.</span></span><span class="sig-name descname"><span class="pre">RidgeEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeencoder.py#L361"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeencoder.RidgeEncoder" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a linear ridge encoder.</p>
<p>This encoder maps features <span class="math notranslate nohighlight">\(X\)</span> to neural data <span class="math notranslate nohighlight">\(y\)</span> through
the forward model <span class="math notranslate nohighlight">\(\beta\)</span>:</p>
<div class="math notranslate nohighlight">
\[y = \beta X + \varepsilon\]</div>
<p>Consequently, we solve for the forward model through:</p>
<div class="math notranslate nohighlight">
\[\arg\min_{\beta} \sum_i(y_i - \beta^T X_i)^2 + \alpha_\beta \lvert\lvert\beta\rvert\rvert^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_\beta\)</span> are the penalties to test in LOO-CV.</p>
<p>Unlike a standard <a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a>, this class also supports solving
for the full encoding model (including all time points) at once, using a single alpha.
This may be useful when trying to avoid different alphas at different time steps, as would
be the case when using <a class="reference internal" href="../modules/generated/mvpy.estimators.Sliding.html#mvpy.estimators.Sliding" title="mvpy.estimators.Sliding"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sliding</span></code></a> to slide over the temporal
dimension when encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.Tensor | float | int, default=1</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments for the estimator.</p>
</dd>
<dt><strong>estimator</strong><span class="classifier">mvpy.estimators.RidgeCV</span></dt><dd><p>The estimator to use.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The intercepts of the encoder of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">n_channels)</span></code>.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The coefficients of the encoder of shape <code class="docutils literal notranslate"><span class="pre">(n_features,</span> <span class="pre">n_channels[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.RidgeCV.html#mvpy.estimators.RidgeCV" title="mvpy.estimators.RidgeCV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.RidgeCV</span></code></a></dt><dd><p>The estimator used for encoding.</p>
</dd>
<dt><a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.TimeDelayed</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.estimators.ReceptiveField.html#mvpy.estimators.ReceptiveField" title="mvpy.estimators.ReceptiveField"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.estimators.ReceptiveField</span></code></a></dt><dd><p>Alternative estimators for explicitly modeling temporal response functions.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This assumes a one-to-one mapping in feature and neural time. This is, of course,
principally wrong, but may be good enough when we have a simple set of features
and want to find out at what points in time they might correspond to neural
data, for example for regressing semantic embeddings on neural data. For more explicit
modeling of temporal response functions, see <a class="reference internal" href="../modules/generated/mvpy.estimators.TimeDelayed.html#mvpy.estimators.TimeDelayed" title="mvpy.estimators.TimeDelayed"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a>
or <a class="reference internal" href="../modules/generated/mvpy.estimators.ReceptiveField.html#mvpy.estimators.ReceptiveField" title="mvpy.estimators.ReceptiveField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceptiveField</span></code></a>.</p>
<p class="rubric">Examples</p>
<p>Let’s say we want to do a very simple encoding:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">RidgeEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 50])</span>
</pre></div>
</div>
<p>Next, let’s assume we want to do a temporally expanded encoding instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeEncoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">ß</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ß</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">RidgeEncoder</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([60, 5, 100])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeencoder.RidgeEncoder.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgeencoder.RidgeEncoder" title="mvpy.estimators.ridgeencoder.RidgeEncoder"><span class="pre">RidgeEncoder</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeencoder.py#L510"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>encoder</strong><span class="classifier">mvpy.estimators.RidgeEncoder</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeencoder.RidgeEncoder.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.ridgeencoder.RidgeEncoder" title="mvpy.estimators.ridgeencoder.RidgeEncoder"><span class="pre">RidgeEncoder</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeencoder.py#L476"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
<dt><strong>y</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The neural data of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>encoder</strong><span class="classifier">mvpy.estimators.RidgeEncoder</span></dt><dd><p>The fitted encoder.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgeencoder.RidgeEncoder.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/ridgeencoder.py#L494"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The features of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_features[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The predictions of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels[,</span> <span class="pre">n_timepoints])</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.rsa">
<span id="mvpy-estimators-rsa-module"></span><h2>mvpy.estimators.rsa module<a class="headerlink" href="#module-mvpy.estimators.rsa" title="Link to this heading">#</a></h2>
<p>A collection of estimators for computing
representational similarities.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.rsa.</span></span><span class="sig-name descname"><span class="pre">RSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grouped:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator:</span> <span class="pre">~typing.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">euclidean&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs:</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L557"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements representational similarity analysis.</p>
<p>Representational similarity analysis computes the geometry of input
data <span class="math notranslate nohighlight">\(X\)</span> in their feature space. For example, given input
data <span class="math notranslate nohighlight">\(X\)</span> of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>, 
it would compute representational (dis-)similarity matrices of shape 
<code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_trials,</span> <span class="pre">n_timepoints)</span></code> through some (dis-)similarity
function <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>Generally, performing this over representations of different systems
allows drawing second-order comparisons about shared properties of
those systems. This is typically done by computing  multiple (dis-)similarity 
matrices from neural and simulated data before comparing the two using, 
for example, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.spearmanr" title="mvpy.math.spearmanr"><code class="xref py py-func docutils literal notranslate"><span class="pre">spearmanr()</span></code></a> to obtain a measure of 
how similar some hypothetical simulated system is to the observed
neural geometry.</p>
<p>For more information on representational similarity analysis,
please see <a class="reference internal" href="#r307081779673-1" id="id37">[1]</a> <a class="reference internal" href="#r307081779673-2" id="id38">[2]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grouped</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use a grouped RSA (this is required for cross-validated metrics to make sense, irrelevant otherwise).</p>
</dd>
<dt><strong>estimator</strong><span class="classifier">Callable, default=mvpy.math.euclidean</span></dt><dd><p>The estimator/metric to use for RDM computation.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int, default=None</span></dt><dd><p>Number of jobs to run in parallel (default = None).</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to print progress information.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rdm_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The upper triangle of the representational (dis-)similarity matrix of shape <code class="docutils literal notranslate"><span class="pre">(n_triu_indices[,</span> <span class="pre">...])</span></code>.</p>
</dd>
<dt><strong>cx_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The upper triangular indices of the RDM.</p>
</dd>
<dt><strong>cy_</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The upper triangular indices of the RDM.</p>
</dd>
<dt><strong>grouped</strong><span class="classifier">bool</span></dt><dd><p>Whether the RSA is grouped.</p>
</dd>
<dt><strong>estimator</strong><span class="classifier">Callable</span></dt><dd><p>The estimator/metric to use for RDM computation.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">int</span></dt><dd><p>Number of jobs to run in parallel.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to print progress information.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="mvpy.math.html#module-mvpy.math.cosine" title="mvpy.math.cosine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.cosine</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.math.cosine_d.html#mvpy.math.cosine_d" title="mvpy.math.cosine_d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.cosine_d</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.math.cv_euclidean.html#mvpy.math.cv_euclidean" title="mvpy.math.cv_euclidean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.cv_euclidean</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.math.cv_mahalanobis.html#mvpy.math.cv_mahalanobis" title="mvpy.math.cv_mahalanobis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.cv_mahalanobis</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.euclidean" title="mvpy.math.euclidean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.euclidean</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.mahalanobis" title="mvpy.math.mahalanobis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.mahalanobis</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.pearsonr" title="mvpy.math.pearsonr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.pearsonr</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.math.pearsonr_d.html#mvpy.math.pearsonr_d" title="mvpy.math.pearsonr_d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.pearsonr_d</span></code></a>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.spearmanr" title="mvpy.math.spearmanr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.spearmanr</span></code></a>, <a class="reference internal" href="../modules/generated/mvpy.math.spearmanr_d.html#mvpy.math.spearmanr_d" title="mvpy.math.spearmanr_d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mvpy.math.spearmanr_d</span></code></a></dt><dd><p>Available (dis-)similarity functions.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Computing (dis-)similarity across input data <span class="math notranslate nohighlight">\(X\)</span> may be inherently
biassed. For example, distance metrics like <a class="reference internal" href="mvpy.math.html#module-mvpy.math.euclidean" title="mvpy.math.euclidean"><code class="xref py py-func docutils literal notranslate"><span class="pre">euclidean()</span></code></a> 
or <a class="reference internal" href="mvpy.math.html#module-mvpy.math.mahalanobis" title="mvpy.math.mahalanobis"><code class="xref py py-func docutils literal notranslate"><span class="pre">mahalanobis()</span></code></a> may never truly be zero given the 
noise inherent to neural responses. Consequently, cross-validation can
be applied to compute unbiassed estimators through <a class="reference internal" href="../modules/generated/mvpy.math.cv_euclidean.html#mvpy.math.cv_euclidean" title="mvpy.math.cv_euclidean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cv_euclidean()</span></code></a> 
or <a class="reference internal" href="../modules/generated/mvpy.math.cv_mahalanobis.html#mvpy.math.cv_mahalanobis" title="mvpy.math.cv_mahalanobis"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cv_mahalanobis()</span></code></a>. To do this, make sure to collect
many trials per condition and structure your data <span class="math notranslate nohighlight">\(X\)</span> as 
<code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_groups,</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code> while setting
<code class="xref py py-attr docutils literal notranslate"><span class="pre">grouped</span></code> <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>For more information on cross-validation, please see <a class="reference internal" href="#r307081779673-3" id="id39">[3]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r307081779673-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">1</a><span class="fn-bracket">]</span></span>
<p>Kriegeskorte, N. (2008). Representational similarity analaysis - connecting the branches of systems neuroscience. Frontiers in Systems Neuroscience. 10.3389/neuro.06.004.2008</p>
</div>
<div class="citation" id="r307081779673-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">2</a><span class="fn-bracket">]</span></span>
<p>Diedrichsen, J., &amp; Kriegeskorte, N. (2017). Representational models: A common framework for understanding encoding, pattern-component, and representational similarity analysis. PLOS Computational Biology, 13, e1005508. 10.1371/journal.pcbi.1005508</p>
</div>
<div class="citation" id="r307081779673-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id39">3</a><span class="fn-bracket">]</span></span>
<p>Diedrichsen, J., Provost, S., &amp; Zareamoghaddam, H. (2016). On the distribution of cross-validated mahalanobis distances. arXiv. 10.48550/arXiv.1607.01371</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>Let’s assume we have some data with 100 trials and 5 groups, recording 10 channels over 50 time points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.math</span><span class="w"> </span><span class="kn">import</span> <span class="n">euclidean</span><span class="p">,</span> <span class="n">cv_euclidean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RSA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">(</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">euclidean</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4950, 5, 50])</span>
</pre></div>
</div>
<p>If we want to compute a cross-validated RSA over the groups instead, we can use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">(</span><span class="n">grouped</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">estimator</span> <span class="o">=</span> <span class="n">cv_euclidean</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 50])</span>
</pre></div>
</div>
<p>Finally, if we want to plot the full RDM, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rdm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdm</span><span class="p">[</span><span class="n">rsa</span><span class="o">.</span><span class="n">cx_</span><span class="p">,</span> <span class="n">rsa</span><span class="o">.</span><span class="n">cy_</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsa</span><span class="o">.</span><span class="n">rdm_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rdm</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;RdBu_r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L793"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rsa</strong><span class="classifier">mvpy.estimators.RSA</span></dt><dd><p>A clone of this class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.rsa.RSA" title="mvpy.estimators.rsa.RSA"><span class="pre">RSA</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L706"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The data to compute the RDM for of shape <code class="docutils literal notranslate"><span class="pre">(n_trials[,</span> <span class="pre">n_groups],</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rsa</strong><span class="classifier">mvpy.estimators.RSA</span></dt><dd><p>Fitted RSA estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L742"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator and transform data into representational similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The data to compute the RDM for of shape <code class="docutils literal notranslate"><span class="pre">(n_trials[,</span> <span class="pre">n_groups],</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rdm</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The representational similarity matrix of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_trials,</span> <span class="pre">n_timepoints)</span></code> or <code class="docutils literal notranslate"><span class="pre">(n_groups,</span> <span class="pre">n_groups,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.full_rdm">
<span class="sig-name descname"><span class="pre">full_rdm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L782"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.full_rdm" title="Link to this definition">#</a></dt>
<dd><p>Obtain the full representational similartiy matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rdm</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The representational similarity matrix of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_trials,</span> <span class="pre">n_timepoints)</span></code> or <code class="docutils literal notranslate"><span class="pre">(n_groups,</span> <span class="pre">n_groups,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L771"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Make this estimator use the numpy backend. Note that this method does not support conversion between types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rsa</strong><span class="classifier">sklearn.base.BaseEstimator</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L760"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Make this estimator use the torch backend. Note that this method does not support conversion between types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rsa</strong><span class="classifier">sklearn.base.BaseEstimator</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/rsa.py#L724"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.rsa.RSA.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the data into representational similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The data to compute the RDM for of shape <code class="docutils literal notranslate"><span class="pre">(n_trials[,</span> <span class="pre">n_groups],</span> <span class="pre">n_channels,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rdm</strong><span class="classifier">np.ndarray | torch.Tensor</span></dt><dd><p>The representational similarity matrix of shape <code class="docutils literal notranslate"><span class="pre">(n_trials,</span> <span class="pre">n_trials,</span> <span class="pre">n_timepoints)</span></code> or <code class="docutils literal notranslate"><span class="pre">(n_groups,</span> <span class="pre">n_groups,</span> <span class="pre">n_timepoints)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.sliding">
<span id="mvpy-estimators-sliding-module"></span><h2>mvpy.estimators.sliding module<a class="headerlink" href="#module-mvpy.estimators.sliding" title="Link to this heading">#</a></h2>
<p>A collection of estimators that allow for sliding other estimators over a dimension of the data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.sliding.</span></span><span class="sig-name descname"><span class="pre">Sliding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L772"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a sliding estimator that allows you to fit estimators iteratively over a set of dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>estimator</strong><span class="classifier">Callable, sklearn.base.BaseEstimator</span></dt><dd><p>Estimator to use.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">Union[int, tuple, list, np.ndarray, torch.Tensor], default=-1</span></dt><dd><p>Dimensions to slide over.</p>
</dd>
<dt><strong>n_jobs</strong><span class="classifier">Union[int, None], default=None</span></dt><dd><p>Number of jobs to run in parallel.</p>
</dd>
<dt><strong>top</strong><span class="classifier">bool, default=True</span></dt><dd><p>Is this a top-level estimator?</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to print progress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>estimators_</strong><span class="classifier">list</span></dt><dd><p>List of fitted estimators.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This class generally expects that your input data is of shape (n_trials, […], n_channels, […]). Make sure that your data and dimension selection is appropriate for the estimator you wish to fit.
Note also that, when fitting estimators, you _must_ have an equal number of dimensions in X and y. If you do not, please simply pad to the same dimension length.
Finally, be aware that, if you want to use numpy as your backend, you _must_ supply <cite>dims</cite> as a numpy array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sliding</span><span class="p">,</span> <span class="n">Decoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># trials x searchlights x channels x time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># trials x searchlights x outcomes x time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliding</span> <span class="o">=</span> <span class="n">Sliding</span><span class="p">(</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># slide over searchlights and time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliding</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patterns</span> <span class="o">=</span> <span class="n">sliding</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="s1">&#39;pattern_&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patterns</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([50, 100, 4, 5])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L969"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Sliding</dt><dd><p>Cloned class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.collect">
<span class="sig-name descname"><span class="pre">collect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L953"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.collect" title="Link to this definition">#</a></dt>
<dd><p>Collect the attribute of the estimators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>attr</strong><span class="classifier">str</span></dt><dd><p>Attribute to collect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>Collected attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L858"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Target data.</p>
</dd>
<dt><strong>*args</strong></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L893"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit and transform the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Target data.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>Transformed data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L913"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor, None], default=None</span></dt><dd><p>Target data.</p>
</dd>
<dt><strong>*args</strong></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>Predicted targets.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L933"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict the probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor, None], default=None</span></dt><dd><p>Target data.</p>
</dd>
<dt><strong>*args</strong></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>Predicted probabilities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/sliding.py#L873"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor, None], default=None</span></dt><dd><p>Target data.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>Transformed data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.svc">
<span id="mvpy-estimators-svc-module"></span><h2>mvpy.estimators.svc module<a class="headerlink" href="#module-mvpy.estimators.svc" title="Link to this heading">#</a></h2>
<p>A collection of estimators for support vector classification.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.svc.</span></span><span class="sig-name descname"><span class="pre">SVC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OvR'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'scale'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coef0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L815"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a support vector classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str, default=’OvR’</span></dt><dd><p>For multiclass problems, which method should we use? One-versus-one (OvO) or one-versus-rest (OvR)?</p>
</dd>
<dt><strong>C</strong><span class="classifier">float, default=1.0</span></dt><dd><p>Regularisation strength is inversely related to C.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">str, default=’linear’</span></dt><dd><p>Which kernel function should we use (linear, poly, rbf, sigmoid)?</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">Union[str, float], default=’scale’</span></dt><dd><p>What gamma to use for poly, rbf and sigmoid. Available methods are scale or auto, or positive float.</p>
</dd>
<dt><strong>coef0</strong><span class="classifier">float, default=0.0</span></dt><dd><p>What offset to use for poly and sigmoid.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">float, default=3.0</span></dt><dd><p>What degree polynomial to use (if any).</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, default=1e-3</span></dt><dd><p>Tolerance over maximum update step (i.e., when maximal gradient &lt; tol, early stopping is triggered).</p>
</dd>
<dt><strong>lr</strong><span class="classifier">float, default=1e-3</span></dt><dd><p>The learning rate.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, default=1000</span></dt><dd><p>The maximum number of iterations to perform while fitting, or -1 to disable.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str, default=’OvR’</span></dt><dd><p>For multiclass problems, which method should we use? One-versus-one (OvO) or one-versus-rest (OvR)?</p>
</dd>
<dt><strong>C</strong><span class="classifier">float, default=1.0</span></dt><dd><p>Regularisation strength is inversely related to C.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">str, default=’linear’</span></dt><dd><p>Which kernel function should we use (linear, poly, rbf, sigmoid)?</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">Union[str, float], default=’scale’</span></dt><dd><p>What gamma to use for poly, rbf and sigmoid. Available methods are scale or auto, or positive float.</p>
</dd>
<dt><strong>coef0</strong><span class="classifier">float, default=0.0</span></dt><dd><p>What offset to use for poly and sigmoid.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">float, default=3.0</span></dt><dd><p>What degree polynomial to use (if any).</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, default=1e-3</span></dt><dd><p>Tolerance over maximum update step (i.e., when maximal gradient &lt; tol, early stopping is triggered).</p>
</dd>
<dt><strong>lr</strong><span class="classifier">float, default=1e-3</span></dt><dd><p>The learning rate.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, default=1000</span></dt><dd><p>The maximum number of iterations to perform while fitting, or -1 to disable.</p>
</dd>
<dt><strong>X_train_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>A clone of the training data used internally for kernel estimation.</p>
</dd>
<dt><strong>A_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>A clone of the alpha data used internally for kernel estimation.</p>
</dd>
<dt><strong>gamma_</strong><span class="classifier">float</span></dt><dd><p>Estimated gamma parameter.</p>
</dd>
<dt><strong>eps_</strong><span class="classifier">float, default=1e-12</span></dt><dd><p>Error margin for support vectors used internally.</p>
</dd>
<dt><strong>w_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>If linear kernel, estimated weights.</p>
</dd>
<dt><strong>p_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>If linear kernel, estimated patterns.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The intercept vector.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>If linear kernel, the coefficients of the model.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>If linear kernel, the patterns used by the model.</p>
</dd>
<dt><strong>binariser_</strong><span class="classifier">LabelBinariser</span></dt><dd><p>The binariser used internally.</p>
</dd>
<dt><strong>scaler_</strong><span class="classifier">Scaler</span></dt><dd><p>The scaler used internally.</p>
</dd>
</dl>
</dd>
</dl>
<p>vert - maxlvert grad_{i-1}
vert &lt; 
artheta</p>
<blockquote>
<div><p>where :math:<a href="#id43"><span class="problematic" id="id44">`</span></a></p>
</div></blockquote>
<p>artheta` is the tolerance. Note that this also diverges from sklearn’s implementation which is violation-based.</p>
<blockquote>
<div><p>This is likely to change in the future. Ideally, we will want to use an SMO approach, which should be much faster than the current full gradient ascent. It is a bit of a pickle, because SVC is difficult to optimise for GPUs. There are also new interesting directions like fitting parameters (e.g., gamma) directly, which might be interesting here. For more information, see <span id="id45">[Rca68086fb168-1]</span>. We will revisit this implementation.</p>
<p>Note also that coefficients are only interpretable in the linear case, and therefore this class automatically prevents access in other cases. Given a linear kernel, however, this class will also automatically compute the patterns used for classification, available as <a href="#id51"><span class="problematic" id="id52">pattern_</span></a>. For more information, see <span id="id46">[Rca68086fb168-2]</span>.</p>
<p>Note also that this class will rarely be public-facing, as at runtime it is wrapped in a Classifier class which handles OvR/OvO modes. By default, OvR will make predictions based on maximum decision values, whereas OvO will make voting-based decisions between all classifiers.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<p>First, let’s look at a case where we have one feature that has two classes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_circles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_circles</span><span class="p">(</span><span class="n">noise</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_h</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y_h</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">y</span><span class="p">)</span>
<span class="go">tensor(0.6700)</span>
</pre></div>
</div>
<p>Second, let’s look at a case where we have one feature that has three classes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_h</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y_h</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">y</span><span class="p">)</span>
<span class="go">tensor(0.9733)</span>
</pre></div>
</div>
<p>Third, let’s look at a case where we have two features with a variable number of classes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_classification</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_classes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_informative</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">(</span><span class="n">n_classes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n_informative</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_h</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y_h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="go">tensor([1.000, 0.9800])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.svc.SVC" title="mvpy.estimators.svc.SVC"><span class="pre">SVC</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1114"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">SVC</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.svc.SVC" title="mvpy.estimators.svc.SVC"><span class="pre">SVC</span></a></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1135"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.copy" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">SVC</span></dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.decision_function">
<span class="sig-name descname"><span class="pre">decision_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1044"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.decision_function" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features (n_samples, n_channels).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The predictions of shape (n_samples, n_classes).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1026"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features of shape (n_samples, n_channels).</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The targets of shape (n_samples[, n_features]).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">Classifier</span></dt><dd><p>The classifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1060"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features (n_samples, n_channels).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y_h</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The predictions of shape (n_samples, n_features).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1076"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features (n_samples, n_channels).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The predictions of shape (n_samples, n_classes).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1103"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Obtain the estimator with numpy as backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">_Classifier_numpy</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.svc.SVC.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BaseEstimator</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/svc.py#L1092"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.svc.SVC.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Obtain the estimator with torch as backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>clf</strong><span class="classifier">_Classifier_torch</span></dt><dd><p>The estimator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators.timedelayed">
<span id="mvpy-estimators-timedelayed-module"></span><h2>mvpy.estimators.timedelayed module<a class="headerlink" href="#module-mvpy.estimators.timedelayed" title="Link to this heading">#</a></h2>
<p>A collection of estimators for TimeDelayed modeling (mTRF + SR).</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.timedelayed.</span></span><span class="sig-name descname"><span class="pre">TimeDelayed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">tensor([1])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patterns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/timedelayed.py#L511"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements TimeDelayed regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t_min</strong><span class="classifier">float</span></dt><dd><p>The minimum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float</span></dt><dd><p>The maximum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>The sampling frequency.</p>
</dd>
<dt><strong>alphas</strong><span class="classifier">Union[np.ndarray, torch.Tensor], default=torch.tensor([1])</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>patterns</strong><span class="classifier">bool, default=False</span></dt><dd><p>Should patterns be estimated?</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments for the estimator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>alphas</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The penalties to use for estimation.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">Any</span></dt><dd><p>Additional arguments.</p>
</dd>
<dt><strong>patterns</strong><span class="classifier">bool</span></dt><dd><p>Should patterns be estimated?</p>
</dd>
<dt><strong>t_min</strong><span class="classifier">float</span></dt><dd><p>The minimum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
</dd>
<dt><strong>t_max</strong><span class="classifier">float</span></dt><dd><p>The maximum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
</dd>
<dt><strong>fs</strong><span class="classifier">int</span></dt><dd><p>The sampling frequency.</p>
</dd>
<dt><strong>window</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The window to use for estimation.</p>
</dd>
<dt><strong>estimator</strong><span class="classifier">mvpy.estimators.RidgeCV</span></dt><dd><p>The estimator to use.</p>
</dd>
<dt><strong>f_</strong><span class="classifier">int</span></dt><dd><p>The number of output features.</p>
</dd>
<dt><strong>c_</strong><span class="classifier">int</span></dt><dd><p>The number of input features.</p>
</dd>
<dt><strong>w_</strong><span class="classifier">int</span></dt><dd><p>The number of time delays.</p>
</dd>
<dt><strong>intercept_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The intercepts of the estimator.</p>
</dd>
<dt><strong>coef_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The coefficients of the estimator.</p>
</dd>
<dt><strong>pattern_</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The patterns of the estimator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This class allows estimation of either multivariate temporal response functions (mTRF) or stimulus reconstruction (SR) models.</p>
<p>mTRFs are estimated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}r(t,n) = \\sum_\\tau w(\\tau, n) s(t - \\tau) + \\epsilon\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the reconstructed signal at timepoint <span class="math notranslate nohighlight">\(t\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(s(t)\)</span> is the stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(w(\tau, n)\)</span> is the weight at time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, and <span class="math notranslate nohighlight">\(\epsilon\)</span> is the error.</p>
<p>SR models are estimated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}s(t) = \\sum_n\\sum_\\tau r(t + \\tau, n) g(\\tau, n)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(s(t)\)</span> is the reconstructed stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the neural response at <span class="math notranslate nohighlight">\(t\)</span> and lagged by <span class="math notranslate nohighlight">\(\\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(g(\tau, n)\)</span> is the weight at time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>For more information on mTRF or SR models, see <a class="reference internal" href="#r9e5b9f7cb6cf-1" id="id47">[1]</a>.</p>
<p>Note that for SR models it is recommended to also pass <cite>patterns=True</cite> to estimate not only the coefficients but also the patterns that were actually used for reconstructing stimuli. For more information, see <a class="reference internal" href="#r9e5b9f7cb6cf-2" id="id48">[2]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r9e5b9f7cb6cf-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id47">1</a><span class="fn-bracket">]</span></span>
<p>Crosse, M.J., Di Liberto, G.M., Bednar, A., &amp; Lalor, E.C. (2016). The multivariate temporal response function (mTRF) toolbox: A MATLAB toolbox for relating neural signals to continuous stimuli. Frontiers in Human Neuroscience, 10, 604. 10.3389/fnhum.2016.00604</p>
</div>
<div class="citation" id="r9e5b9f7cb6cf-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id48">2</a><span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>For mTRF estimation, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeDelayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span> <span class="o">=</span> <span class="n">TimeDelayed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coef_</span>
<span class="go">tensor([[[0.9290, 1.9101, 2.8802, 1.9790, 0.9453]]])</span>
</pre></div>
</div>
<p>For stimulus reconstruction, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeDelayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">50</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">TimeDelayed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">patterns</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="go">tensor([ 1.3591,  1.2549,  1.5662,  2.3544,  3.3440,  4.3683,  5.4097,  6.4418, 7.4454,  8.4978,  9.5206, 10.5374, 11.5841, 12.6102, 13.6254, 14.6939, 15.6932, 16.7168, 17.7619, 18.8130, 19.8182, 20.8687, 21.8854, 22.9310, 23.9270, 24.9808, 26.0085, 27.0347, 28.0728, 29.0828, 30.1400, 31.1452, 32.1793, 33.2047, 34.2332, 35.2717, 36.2945, 37.3491, 38.3800, 39.3817, 40.3962, 41.4489, 42.4854, 43.4965, 44.5346, 45.5716, 46.7301, 47.2251, 48.4449, 48.8793])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/timedelayed.py#L683"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>Decoder</dt><dd><p>The cloned object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/timedelayed.py#L654"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features.</p>
</dd>
<dt><strong>y</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The targets.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span></span><a class="reference external" href="https://github.com/FabulousFabs/mvpy/blob/e0441e4/mvpy/estimators/timedelayed.py#L667"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">Union[np.ndarray, torch.Tensor]</span></dt><dd><p>The features.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Union[np.ndarray, torch.Tensor]</dt><dd><p>The predictions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Configure global settings and get information about the working environment.</p>
<p>The torch package contains data structures for multi-dimensional</p>
</section>
<section id="module-mvpy.estimators">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-mvpy.estimators" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding and disentangling features using back2back regression.</p>
<p>A collection of estimators for decoding features using ridge classifiers.</p>
<p>A collection of estimators for covariance estimation and</p>
<p>A collection of estimators for common spatial patterns.</p>
<p>A collection of estimators for fitting cross-validated ridge regressions.</p>
<p>A collection of estimators for ReceptiveField modeling (mTRF + SR).</p>
<p>A collection of estimators for ridge classification.</p>
<p>A collection of estimators for fitting cross-validated ridge regressions.</p>
<p>A collection of estimators for decoding features using ridge decoders.</p>
<p>A collection of estimators for encoding features using ridge regressions.</p>
<p>A collection of estimators for computing</p>
<p>A collection of estimators that allow for sliding other estimators over a dimension of the data.</p>
<p>A collection of estimators for support vector classification.</p>
<p>A collection of estimators for TimeDelayed modeling (mTRF + SR).</p>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.b2b">mvpy.estimators.b2b module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B"><code class="docutils literal notranslate"><span class="pre">B2B</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.clone"><code class="docutils literal notranslate"><span class="pre">B2B.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.fit"><code class="docutils literal notranslate"><span class="pre">B2B.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.predict"><code class="docutils literal notranslate"><span class="pre">B2B.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.classifier">mvpy.estimators.classifier module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier"><code class="docutils literal notranslate"><span class="pre">Classifier</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.clone"><code class="docutils literal notranslate"><span class="pre">Classifier.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.copy"><code class="docutils literal notranslate"><span class="pre">Classifier.copy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.decision_function"><code class="docutils literal notranslate"><span class="pre">Classifier.decision_function()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.fit"><code class="docutils literal notranslate"><span class="pre">Classifier.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.predict"><code class="docutils literal notranslate"><span class="pre">Classifier.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">Classifier.predict_proba()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.to_numpy"><code class="docutils literal notranslate"><span class="pre">Classifier.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.to_torch"><code class="docutils literal notranslate"><span class="pre">Classifier.to_torch()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.covariance">mvpy.estimators.covariance module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance"><code class="docutils literal notranslate"><span class="pre">Covariance</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.clone"><code class="docutils literal notranslate"><span class="pre">Covariance.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.fit"><code class="docutils literal notranslate"><span class="pre">Covariance.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.fit_transform"><code class="docutils literal notranslate"><span class="pre">Covariance.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.to_numpy"><code class="docutils literal notranslate"><span class="pre">Covariance.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.to_torch"><code class="docutils literal notranslate"><span class="pre">Covariance.to_torch()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.transform"><code class="docutils literal notranslate"><span class="pre">Covariance.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.csp">mvpy.estimators.csp module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.csp.CSP"><code class="docutils literal notranslate"><span class="pre">CSP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.csp.CSP.clone"><code class="docutils literal notranslate"><span class="pre">CSP.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.csp.CSP.fit"><code class="docutils literal notranslate"><span class="pre">CSP.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.csp.CSP.predict"><code class="docutils literal notranslate"><span class="pre">CSP.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.kernelridgecv">mvpy.estimators.kernelridgecv module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV"><code class="docutils literal notranslate"><span class="pre">KernelRidgeCV</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.clone"><code class="docutils literal notranslate"><span class="pre">KernelRidgeCV.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.fit"><code class="docutils literal notranslate"><span class="pre">KernelRidgeCV.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.kernelridgecv.KernelRidgeCV.predict"><code class="docutils literal notranslate"><span class="pre">KernelRidgeCV.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.receptivefield">mvpy.estimators.receptivefield module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.receptivefield.ReceptiveField"><code class="docutils literal notranslate"><span class="pre">ReceptiveField</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.receptivefield.ReceptiveField.fit"><code class="docutils literal notranslate"><span class="pre">ReceptiveField.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.receptivefield.ReceptiveField.predict"><code class="docutils literal notranslate"><span class="pre">ReceptiveField.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.ridgeclassifier">mvpy.estimators.ridgeclassifier module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.clone"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.copy"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.copy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.decision_function"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.decision_function()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.fit"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.predict"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeclassifier.RidgeClassifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">RidgeClassifier.predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.ridgecv">mvpy.estimators.ridgecv module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV"><code class="docutils literal notranslate"><span class="pre">RidgeCV</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.clone"><code class="docutils literal notranslate"><span class="pre">RidgeCV.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.fit"><code class="docutils literal notranslate"><span class="pre">RidgeCV.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.predict"><code class="docutils literal notranslate"><span class="pre">RidgeCV.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.ridgedecoder">mvpy.estimators.ridgedecoder module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgedecoder.RidgeDecoder"><code class="docutils literal notranslate"><span class="pre">RidgeDecoder</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.clone"><code class="docutils literal notranslate"><span class="pre">RidgeDecoder.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.fit"><code class="docutils literal notranslate"><span class="pre">RidgeDecoder.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgedecoder.RidgeDecoder.predict"><code class="docutils literal notranslate"><span class="pre">RidgeDecoder.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.ridgeencoder">mvpy.estimators.ridgeencoder module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeencoder.RidgeEncoder"><code class="docutils literal notranslate"><span class="pre">RidgeEncoder</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.clone"><code class="docutils literal notranslate"><span class="pre">RidgeEncoder.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.fit"><code class="docutils literal notranslate"><span class="pre">RidgeEncoder.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgeencoder.RidgeEncoder.predict"><code class="docutils literal notranslate"><span class="pre">RidgeEncoder.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.rsa">mvpy.estimators.rsa module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA"><code class="docutils literal notranslate"><span class="pre">RSA</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.clone"><code class="docutils literal notranslate"><span class="pre">RSA.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.fit"><code class="docutils literal notranslate"><span class="pre">RSA.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.fit_transform"><code class="docutils literal notranslate"><span class="pre">RSA.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.full_rdm"><code class="docutils literal notranslate"><span class="pre">RSA.full_rdm()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.to_numpy"><code class="docutils literal notranslate"><span class="pre">RSA.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.to_torch"><code class="docutils literal notranslate"><span class="pre">RSA.to_torch()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.transform"><code class="docutils literal notranslate"><span class="pre">RSA.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.sliding">mvpy.estimators.sliding module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding"><code class="docutils literal notranslate"><span class="pre">Sliding</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.clone"><code class="docutils literal notranslate"><span class="pre">Sliding.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.collect"><code class="docutils literal notranslate"><span class="pre">Sliding.collect()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.fit"><code class="docutils literal notranslate"><span class="pre">Sliding.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.fit_transform"><code class="docutils literal notranslate"><span class="pre">Sliding.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.predict"><code class="docutils literal notranslate"><span class="pre">Sliding.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.predict_proba"><code class="docutils literal notranslate"><span class="pre">Sliding.predict_proba()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.transform"><code class="docutils literal notranslate"><span class="pre">Sliding.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.svc">mvpy.estimators.svc module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC"><code class="docutils literal notranslate"><span class="pre">SVC</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.clone"><code class="docutils literal notranslate"><span class="pre">SVC.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.copy"><code class="docutils literal notranslate"><span class="pre">SVC.copy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.decision_function"><code class="docutils literal notranslate"><span class="pre">SVC.decision_function()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.fit"><code class="docutils literal notranslate"><span class="pre">SVC.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.predict"><code class="docutils literal notranslate"><span class="pre">SVC.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.predict_proba"><code class="docutils literal notranslate"><span class="pre">SVC.predict_proba()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.to_numpy"><code class="docutils literal notranslate"><span class="pre">SVC.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.svc.SVC.to_torch"><code class="docutils literal notranslate"><span class="pre">SVC.to_torch()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.timedelayed">mvpy.estimators.timedelayed module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed"><code class="docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.clone"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.fit"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.predict"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators">Module contents</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/mvpy.estimators.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Fabian Schneider.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>