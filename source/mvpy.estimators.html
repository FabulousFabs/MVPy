
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mvpy.estimators package &#8212; MVPy 0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'source/mvpy.estimators';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="mvpy.math package" href="mvpy.math.html" />
    <link rel="prev" title="mvpy package" href="mvpy.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">MVPy 0.1 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">mvpy.estimators package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.math.html">mvpy.math package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.signal.html">mvpy.signal package</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvpy.utilities.html">mvpy.utilities package</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../documentation/index.html" class="nav-link">Documentation</a></li>
    
    
    <li class="breadcrumb-item"><a href="mvpy.html" class="nav-link">mvpy package</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">mvpy.estimators package</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="mvpy-estimators-package">
<h1>mvpy.estimators package<a class="headerlink" href="#mvpy-estimators-package" title="Link to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">#</a></h2>
</section>
<section id="module-mvpy.estimators.b2b">
<span id="mvpy-estimators-b2b-module"></span><h2>mvpy.estimators.b2b module<a class="headerlink" href="#module-mvpy.estimators.b2b" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding and disentangling features using back2back regression.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.b2b.</span></span><span class="sig-name descname"><span class="pre">B2B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.b2b.B2B" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a back-to-back regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>np.ndarray</em><em>]</em><em>, </em><em>default=torch.tensor</em><em>(</em><em>[</em><em>1</em><em>]</em><em>)</em>) – The penalties to use for estimation.</p></li>
<li><p><strong>fit_intercept</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to fit an intercept.</p></li>
<li><p><strong>normalise</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to normalise the data.</p></li>
<li><p><strong>alpha_per_target</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to use a different penalty for each target.</p></li>
<li><p><strong>normalise_decoder</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to normalise decoder ouputs.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.alphas">
<span class="sig-name descname"><span class="pre">alphas</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.alphas" title="Link to this definition">#</a></dt>
<dd><p>The penalties to use for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.fit_intercept">
<span class="sig-name descname"><span class="pre">fit_intercept</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.fit_intercept" title="Link to this definition">#</a></dt>
<dd><p>Whether to fit an intercept.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.normalise">
<span class="sig-name descname"><span class="pre">normalise</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.normalise" title="Link to this definition">#</a></dt>
<dd><p>Whether to normalise the data</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.alpha_per_target">
<span class="sig-name descname"><span class="pre">alpha_per_target</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.alpha_per_target" title="Link to this definition">#</a></dt>
<dd><p>Whether to use a different penalty for each target.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.normalise_decoder">
<span class="sig-name descname"><span class="pre">normalise_decoder</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.normalise_decoder" title="Link to this definition">#</a></dt>
<dd><p>Whether to normalise decoder ouputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.decoder_">
<span class="sig-name descname"><span class="pre">decoder_</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.decoder_" title="Link to this definition">#</a></dt>
<dd><p>The decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.Decoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.encoder_">
<span class="sig-name descname"><span class="pre">encoder_</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.encoder_" title="Link to this definition">#</a></dt>
<dd><p>The encoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.Decoder</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.scaler_">
<span class="sig-name descname"><span class="pre">scaler_</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.scaler_" title="Link to this definition">#</a></dt>
<dd><p>The scaler.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.Scaler</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.causal_">
<span class="sig-name descname"><span class="pre">causal_</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.causal_" title="Link to this definition">#</a></dt>
<dd><p>The causal contribution of each feature.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.pattern_">
<span class="sig-name descname"><span class="pre">pattern_</span></span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.pattern_" title="Link to this definition">#</a></dt>
<dd><p>The decoded patterns.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>The back-to-back estimator is a two-step estimator that consists of a decoder and an encoder. Effectively, the idea is to first decode all features, then use predictions from the decoder to encode all true features from all predictions. Consequently, this allows us to obtain a disentangled estimate of the causal contribution of each feature.</p>
<p>In practice, this is implemented as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\\hat{G} = (Y_1^T Y_i + \\alpha_Y)^{-1}Y^T X\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\\hat{H} = (X^T X + \\alpha_X)^{-1}X^T Y\hat{G}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\\hat{G}\)</span> is the decoder and <span class="math notranslate nohighlight">\(\\hat{H}\)</span> is the encoder, and <span class="math notranslate nohighlight">\(\\alpha\)</span> are regularisation parameters. Note also that, in practice, we do two additional steps:</p>
<p>Firstly, we split the data in half and train the decoder on the first half and the encoder on the second half of the data. This is done to avoid overfitting.</p>
<p>Secondly, we also (offer an option to) normalise the outputs from our decoder. This isn’t technically required, but it can be helpful if you are using, for example, different alpha penalties per target.</p>
<p>For more information on B2B regression, please see <a href="#id17"><span class="problematic" id="id1">[1]_</span></a>.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>King, J.R., Charton, F., Lopez-Paz, D., &amp; Oquab, M. (2020). Back-to-back regression: Disentangling the influence of correlated factors from multivariate observations. NeuroImage, 220, 117028. 10.1016/j.neuroimage.2020.117028</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">B2B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2b</span> <span class="o">=</span> <span class="n">B2B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2b</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">causal_</span>
<span class="go">tensor([0.4470, 0.4594, 0.0060])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.decoder.Decoder" title="mvpy.estimators.decoder.Decoder">Decoder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.b2b.B2B.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.b2b.B2B.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.classifier">
<span id="mvpy-estimators-classifier-module"></span><h2>mvpy.estimators.classifier module<a class="headerlink" href="#module-mvpy.estimators.classifier" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding features using ridge classifiers.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.classifier.</span></span><span class="sig-name descname"><span class="pre">Classifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OvR'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a ridge classifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>np.ndarray</em><em>, </em><em>float</em><em>, </em><em>int</em><em>]</em><em>, </em><em>default=1</em>) – The penalties to use for estimation.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>default='OvR'</em>) – The method to use for estimation (available: ‘OvR’, ‘OvO’).</p></li>
<li><p><strong>fit_intercept</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to fit an intercept.</p></li>
<li><p><strong>normalise</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to normalise the data.</p></li>
<li><p><strong>alpha_per_target</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to use a different penalty for each target.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.estimators_" title="Link to this definition">#</a></dt>
<dd><p>The estimators.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[sklearn.base.BaseEstimator], optional (only for OvO)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.estimator_">
<span class="sig-name descname"><span class="pre">estimator_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.estimator_" title="Link to this definition">#</a></dt>
<dd><p>The estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sklearn.base.BaseEstimator, optional (only for OvR)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.classes_" title="Link to this definition">#</a></dt>
<dd><p>The classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.intercept_">
<span class="sig-name descname"><span class="pre">intercept_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.intercept_" title="Link to this definition">#</a></dt>
<dd><p>The intercepts of the classifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.coef_">
<span class="sig-name descname"><span class="pre">coef_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.coef_" title="Link to this definition">#</a></dt>
<dd><p>The coefficients of the classifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.pattern_">
<span class="sig-name descname"><span class="pre">pattern_</span></span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.pattern_" title="Link to this definition">#</a></dt>
<dd><p>The patterns of the classifiers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>For multi-class classification, the One-vs-Rest strategy is used by default.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Classifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([150])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.decoder.Decoder" title="mvpy.estimators.decoder.Decoder">Decoder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.classifier.Classifier.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.classifier.Classifier.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.covariance">
<span id="mvpy-estimators-covariance-module"></span><h2>mvpy.estimators.covariance module<a class="headerlink" href="#module-mvpy.estimators.covariance" title="Link to this heading">#</a></h2>
<p>A collection of estimators for covariance estimation and
pre-whitening of data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.covariance.</span></span><span class="sig-name descname"><span class="pre">Covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LedoitWolf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Class for computing covariance, precision and whitening matrices. Note that calling a transform from this clas will whiten the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>default = 'LedoitWolf'</em>) – Which method should be applied for estimation of covariance? (default = LedoitWolf, available = [Empirical, LedoitWolf])</p></li>
<li><p><strong>s_min</strong> (<em>float</em><em>, </em><em>default = None</em>) – What’s the minimum sample we should consider in the time dimension?</p></li>
<li><p><strong>s_max</strong> (<em>float</em><em>, </em><em>default = None</em>) – What’s the maximum sample we should consider in the time dimension?</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.covariance_">
<span class="sig-name descname"><span class="pre">covariance_</span></span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.covariance_" title="Link to this definition">#</a></dt>
<dd><p>Covariance matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.precision_">
<span class="sig-name descname"><span class="pre">precision_</span></span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.precision_" title="Link to this definition">#</a></dt>
<dd><p>Precision matrix (inverse of covariance matrix)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.whitener_">
<span class="sig-name descname"><span class="pre">whitener_</span></span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.whitener_" title="Link to this definition">#</a></dt>
<dd><p>Whitening matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.shrinkage_">
<span class="sig-name descname"><span class="pre">shrinkage_</span></span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.shrinkage_" title="Link to this definition">#</a></dt>
<dd><p>Shrinkage parameter, if used by method.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, optional</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class assumes features to be the second to last dimension of the data, unless there are only two dimensions (in which case it is assumed to be the last dimension).</p>
<p>Currently, we support the following methods:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Empirical:</dt><dd><p>This method simply computes the biassed empirical covariance matrix.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>LedoitWolf:</dt><dd><p>This method computes the Ledoit-Wolf shrinkage estimator as detailed in <a href="#id18"><span class="problematic" id="id3">[1]_</span></a>.</p>
</dd>
</dl>
</li>
</ul>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Ledoit, O., &amp; Wolf, M. (2004). A well-conditioned estimator for large-dimensional covariance matrices. Journal of Multivariate Analysis, 88, 365-411. 10.1016/S0047-259X(03)00096-4</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Covariance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">Covariance</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span><span class="o">.</span><span class="n">covariance_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 10])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.clone" title="Link to this definition">#</a></dt>
<dd><p>Obtain a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance">Covariance</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the covariance estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Data to fit the estimator on.</p></li>
<li><p><strong>*args</strong> (<em>Any</em>) – Additional arguments to pass to the estimator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Fitted covariance estimator.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance">Covariance</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit the covariance estimator and whiten the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Data to fit the estimator on and transform.</p></li>
<li><p><strong>*args</strong> (<em>Any</em>) – Additional arguments to pass to the estimator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – Whitened data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Create the numpy estimator. Note that this function cannot be used for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The numpy estimator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance">Covariance</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Create the torch estimator. Note that this function cannot be used for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The torch estimator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.covariance.Covariance" title="mvpy.estimators.covariance.Covariance">Covariance</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.covariance.Covariance.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.covariance.Covariance.transform" title="Link to this definition">#</a></dt>
<dd><p>Whiten data using the fitted covariance estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Data to transform.</p></li>
<li><p><strong>*args</strong> (<em>Any</em>) – Additional arguments to pass to the estimator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>W</strong> – Whitened data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.decoder">
<span id="mvpy-estimators-decoder-module"></span><h2>mvpy.estimators.decoder module<a class="headerlink" href="#module-mvpy.estimators.decoder" title="Link to this heading">#</a></h2>
<p>A collection of estimators for decoding features using ridge decoders.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.decoder.</span></span><span class="sig-name descname"><span class="pre">Decoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a simple linear ridge decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>np.ndarray</em><em>]</em>) – The penalties to use for estimation.</p></li>
<li><p><strong>fit_intercept</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to fit an intercept.</p></li>
<li><p><strong>normalise</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to normalise the data.</p></li>
<li><p><strong>alpha_per_target</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to use a different penalty for each target.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.estimator_">
<span class="sig-name descname"><span class="pre">estimator_</span></span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.estimator_" title="Link to this definition">#</a></dt>
<dd><p>The ridge estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.RidgeCV</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.pattern_">
<span class="sig-name descname"><span class="pre">pattern_</span></span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.pattern_" title="Link to this definition">#</a></dt>
<dd><p>The decoded pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.coef_">
<span class="sig-name descname"><span class="pre">coef_</span></span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.coef_" title="Link to this definition">#</a></dt>
<dd><p>The coefficeints of the decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.intercept_">
<span class="sig-name descname"><span class="pre">intercept_</span></span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.intercept_" title="Link to this definition">#</a></dt>
<dd><p>The intercepts of the decoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.alpha_">
<span class="sig-name descname"><span class="pre">alpha_</span></span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.alpha_" title="Link to this definition">#</a></dt>
<dd><p>The penalties used for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[torch.Tensor, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>After fitting the decoder, this class will also estimate the decoded patterns. This follows the approach detailed in <a href="#id19"><span class="problematic" id="id5">[4]_</span></a>. Please also be aware that, while this class supports decoding multiple features at once, these will principally be separate regressions wherein individual contributions are not disentangled. If you would like to do this, please consider using a back-to-back decoder.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">pattern_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([60, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.size([100, 5])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.decoder.Decoder" title="mvpy.estimators.decoder.Decoder">Decoder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.decoder.Decoder.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.decoder.Decoder.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.encoder">
<span id="mvpy-estimators-encoder-module"></span><h2>mvpy.estimators.encoder module<a class="headerlink" href="#module-mvpy.estimators.encoder" title="Link to this heading">#</a></h2>
<p>A collection of estimators for encoding features using ridge regressions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.encoder.</span></span><span class="sig-name descname"><span class="pre">Encoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a simple linear ridge encoder. This class essentially just wraps <cite>mvpy.estimators.RidgeCV</cite>, exposing this as a more convenient name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>np.ndarray</em><em>, </em><em>float</em><em>, </em><em>int</em><em>]</em><em>, </em><em>default=1</em>) – The penalties to use for estimation.</p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>) – Additional arguments.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.alphas">
<span class="sig-name descname"><span class="pre">alphas</span></span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.alphas" title="Link to this definition">#</a></dt>
<dd><p>The penalties to use for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.kwargs" title="Link to this definition">#</a></dt>
<dd><p>Additional arguments for the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.estimator" title="Link to this definition">#</a></dt>
<dd><p>The estimator to use.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.RidgeCV</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.intercept_">
<span class="sig-name descname"><span class="pre">intercept_</span></span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.intercept_" title="Link to this definition">#</a></dt>
<dd><p>The intercepts of the encoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.coef_">
<span class="sig-name descname"><span class="pre">coef_</span></span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.coef_" title="Link to this definition">#</a></dt>
<dd><p>The coefficients of the encoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class is a wrapper around <cite>mvpy.estimators.RidgeCV</cite>. Really, it exists mostly to make the code more readable.</p>
<p>However, this class may also be used for a temporally expanded encoder. This may be useful in cases where you would like to encode in time, but would like to impose the constraint that alpha should be fit over all time points. To use this class in this manner, simply supply 3D <cite>X</cite> and <cite>y</cite> tensors.</p>
<p class="rubric">Examples</p>
<p>Let’s say we want to do a very simple encoding:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Encoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">ß</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([1, 50])</span>
</pre></div>
</div>
<p>Next, let’s assume we want to do a temporally expanded encoding instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Encoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">@</span> <span class="n">ß</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ß</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encoder</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([60, 5, 100])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.encoder.Encoder" title="mvpy.estimators.encoder.Encoder">Encoder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.encoder.Encoder.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.encoder.Encoder.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.ridgecv">
<span id="mvpy-estimators-ridgecv-module"></span><h2>mvpy.estimators.ridgecv module<a class="headerlink" href="#module-mvpy.estimators.ridgecv" title="Link to this heading">#</a></h2>
<p>A collection of estimators for fitting cross-validated ridge regressions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.ridgecv.</span></span><span class="sig-name descname"><span class="pre">RidgeCV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_intercept</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_per_target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements RidgeCV using torch as our backend.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>list</em><em>, </em><em>float</em><em>, </em><em>int</em><em>]</em><em>, </em><em>default=torch.Tensor</em><em>(</em><em>[</em><em>1</em><em>]</em><em>)</em>) – Penalties to use for estimation.</p></li>
<li><p><strong>fit_intercept</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to fit an intercept.</p></li>
<li><p><strong>normalise</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to normalise the data.</p></li>
<li><p><strong>alpha_per_target</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Whether to use a different penalty for each target.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.alpha_">
<span class="sig-name descname"><span class="pre">alpha_</span></span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.alpha_" title="Link to this definition">#</a></dt>
<dd><p>The penalties used for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.intercept_">
<span class="sig-name descname"><span class="pre">intercept_</span></span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.intercept_" title="Link to this definition">#</a></dt>
<dd><p>The intercepts.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.coef_">
<span class="sig-name descname"><span class="pre">coef_</span></span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.coef_" title="Link to this definition">#</a></dt>
<dd><p>The coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class owes greatly to J.R. King’s RidgeCV implementation[3]_. If data are supplied as numpy, this class will fall back to :func:<a href="#id7"><span class="problematic" id="id8">`</span></a>sklearn.linear_model.RidgeCV`[4]_.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>King, J.R. (2020). torch_ridge. <a class="github reference external" href="https://github.com/kingjr/torch_ridge">kingjr/torch_ridge</a></p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., … &amp; Vanderplas, J. (2011). Scikit-learn: Machine learning in Python. Journal of Machine Learning Research, 12, 2825-2830.</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RidgeCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ß</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">RidgeCV</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">coef_</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.clone" title="Link to this definition">#</a></dt>
<dd><p>Make a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A clone of this class.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.ridgecv.RidgeCV" title="mvpy.estimators.ridgecv.RidgeCV">RidgeCV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.ridgecv.RidgeCV.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.ridgecv.RidgeCV.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>torch.Tensor</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y</strong> – The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.rsa">
<span id="mvpy-estimators-rsa-module"></span><h2>mvpy.estimators.rsa module<a class="headerlink" href="#module-mvpy.estimators.rsa" title="Link to this heading">#</a></h2>
<p>A collection of estimators for computing
representational similarities.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.rsa.</span></span><span class="sig-name descname"><span class="pre">RSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grouped=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator=&lt;function</span> <span class="pre">euclidean&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements representational similarity analysis as an estimator. Note that this class expects features to be the second to last dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grouped</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to use a grouped RSA (this is required for cross-validated metrics to make sense, irrelevant otherwise).</p></li>
<li><p><strong>estimator</strong> (<em>callable</em><em>, </em><em>default=mv.math.euclidean</em>) – The estimator/metric to use for RDM computation.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>default=None</em>) – Number of jobs to run in parallel (default = None).</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to print progress information.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.rdm_">
<span class="sig-name descname"><span class="pre">rdm_</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.rdm_" title="Link to this definition">#</a></dt>
<dd><p>The representational (dis)similarity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.cx_">
<span class="sig-name descname"><span class="pre">cx_</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.cx_" title="Link to this definition">#</a></dt>
<dd><p>The upper triangular indices of the RDM.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.cy_">
<span class="sig-name descname"><span class="pre">cy_</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.cy_" title="Link to this definition">#</a></dt>
<dd><p>The upper triangular indices of the RDM.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.grouped">
<span class="sig-name descname"><span class="pre">grouped</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.grouped" title="Link to this definition">#</a></dt>
<dd><p>Whether the RSA is grouped.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.estimator" title="Link to this definition">#</a></dt>
<dd><p>The estimator/metric to use for RDM computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.n_jobs" title="Link to this definition">#</a></dt>
<dd><p>Number of jobs to run in parallel.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.verbose" title="Link to this definition">#</a></dt>
<dd><p>Whether to print progress information.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>If you would like to perform, for example, a cross-validated RSA using <code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cv_euclidean()</span></code>, you should make sure that the first dimension in your data is trials, whereas the second dimension groups them meaningfully. The resulting RDM will then be computed over groups, with cross-validation over trials.</p>
<p>For more information on representational similarity, please see <a href="#id20"><span class="problematic" id="id11">[2]_</span></a>.</p>
<p class="rubric">Examples</p>
<p>Let’s assume we have some data with 100 trials and 5 groups, recording 10 channels over 50 time points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.math</span><span class="w"> </span><span class="kn">import</span> <span class="n">euclidean</span><span class="p">,</span> <span class="n">cv_euclidean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">RSA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">(</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">euclidean</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([4950, 5, 50])</span>
</pre></div>
</div>
<p>If we want to compute a cross-validated RSA over the groups instead, we can use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">(</span><span class="n">grouped</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">estimator</span> <span class="o">=</span> <span class="n">cv_euclidean</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10, 50])</span>
</pre></div>
</div>
<p>Finally, if we want to plot the full RDM, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rdm</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdm</span><span class="p">[</span><span class="n">rsa</span><span class="o">.</span><span class="n">cx_</span><span class="p">,</span> <span class="n">rsa</span><span class="o">.</span><span class="n">cy_</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsa</span><span class="o">.</span><span class="n">rdm_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rdm</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;RdBu_r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that if you would like to perform a decoding RSA, you can use a OvR classifier instead. For example, let’s assume we have data from 100 trials, 60 channels and 50 time points. Data are from 5 distinct classes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Classifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kriegeskorte, N. (2008). Representational similarity analaysis - connecting the branches of systems neuroscience. Frontiers in Systems Neuroscience. 10.3389/neuro.06.004.2008</p>
</aside>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="mvpy.math.html#module-mvpy.math.euclidean" title="mvpy.math.euclidean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.euclidean()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cv_euclidean()</span></code>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.cosine" title="mvpy.math.cosine"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cosine()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.cosine_d()</span></code>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.pearsonr" title="mvpy.math.pearsonr"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.pearsonr()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.pearsonr_d()</span></code>, <a class="reference internal" href="mvpy.math.html#module-mvpy.math.spearmanr" title="mvpy.math.spearmanr"><code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.spearmanr()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mvpy.math.spearmanr_d()</span></code></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A clone of this class.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.rsa.RSA" title="mvpy.estimators.rsa.RSA">RSA</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data to compute the RDM for.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator and transform data into representational similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data to compute the RDM for.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rdm</strong> – The representational similarity.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.full_rdm">
<span class="sig-name descname"><span class="pre">full_rdm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.full_rdm" title="Link to this definition">#</a></dt>
<dd><p>Obtain the full representational similartiy matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rdm</strong> – The representational similarity matrix in full.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Make this estimator use the numpy backend. Note that this method does not support conversion between types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The estimator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sklearn.base.BaseEstimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Make this estimator use the torch backend. Note that this method does not support conversion between types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The estimator.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sklearn.base.BaseEstimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.rsa.RSA.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.rsa.RSA.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the data into representational similarity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data to compute the RDM for.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rdm</strong> – The representational similarity.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.scaler">
<span id="mvpy-estimators-scaler-module"></span><h2>mvpy.estimators.scaler module<a class="headerlink" href="#module-mvpy.estimators.scaler" title="Link to this heading">#</a></h2>
<p>A collection of estimators for scaling data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.scaler.</span></span><span class="sig-name descname"><span class="pre">Scaler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>A standard scaler akin to sklearn.preprocessing.StandardScaler. See notes for some differences.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>with_mean</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, center the data before scaling.</p></li>
<li><p><strong>with_std</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If True, scale the data to unit variance.</p></li>
<li><p><strong>dims</strong> (<em>int</em><em>, </em><em>list</em><em> or </em><em>tuple</em><em> of </em><em>ints</em><em>, </em><em>default=None</em>) – The dimensions over which to scale (None for first dimension).</p></li>
<li><p><strong>copy</strong> (<em>bool</em><em>, </em><em>default=False</em>) – If True, the data will be copied.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.shape_">
<span class="sig-name descname"><span class="pre">shape_</span></span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.shape_" title="Link to this definition">#</a></dt>
<dd><p>The shape of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.mean_">
<span class="sig-name descname"><span class="pre">mean_</span></span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.mean_" title="Link to this definition">#</a></dt>
<dd><p>The mean of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.var_">
<span class="sig-name descname"><span class="pre">var_</span></span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.var_" title="Link to this definition">#</a></dt>
<dd><p>The variance of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.scale_">
<span class="sig-name descname"><span class="pre">scale_</span></span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.scale_" title="Link to this definition">#</a></dt>
<dd><p>The scale of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This is a scaler analogous to sklearn.preprocessing.StandardScaler, except that here we support n-dimensional arrays,
and use a degrees-of-freedom correction for computing variances (without the step-wise fitting).</p>
<p>By default, this scaler will compute:</p>
<div class="math notranslate nohighlight">
\[z = \frac{x - \mu}{\sigma}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is the mean and <span class="math notranslate nohighlight">\(\sigma\)</span> is the standard deviation of the data.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Scaler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">tensor([ 9.7033, 10.2510, 10.2483, 10.1274, 10.2013])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaler</span> <span class="o">=</span> <span class="n">Scaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_s</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X_s</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_i</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X_i</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">tensor([ 9.7033, 10.2510, 10.2483, 10.1274, 10.2013])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.clone" title="Link to this definition">#</a></dt>
<dd><p>Obtain a clone of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The clone.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.scaler.Scaler" title="mvpy.estimators.scaler.Scaler">Scaler</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.copy" title="Link to this definition">#</a></dt>
<dd><p>Obtain a copy of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The copy.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.scaler.Scaler" title="mvpy.estimators.scaler.Scaler">Scaler</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the scaler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments.</p></li>
<li><p><strong>sample_weight</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em><em>, </em><em>default=None</em>) – The sample weights.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit and transform the data in one step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments.</p></li>
<li><p><strong>sample_weight</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em><em>, </em><em>default=None</em>) – The sample weights.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.inverse_transform" title="Link to this definition">#</a></dt>
<dd><p>Invert the transform of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The inverse transformed data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mvpy.estimators.scaler.Scaler" title="mvpy.estimators.scaler.Scaler"><span class="pre">Scaler</span></a></span></span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.set_fit_request" title="Link to this definition">#</a></dt>
<dd><p>Configure whether metadata should be requested to be passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<blockquote>
<div><p>Note that this method is only relevant when this estimator is used as a
sub-estimator within a <span class="xref std std-term">meta-estimator</span> and metadata routing is enabled
with <code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please check the <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 1.3.</span></p>
</div>
<dl class="simple">
<dt>sample_weight<span class="classifier">str, True, False, or None,                     default=sklearn.utils.metadata_routing.UNCHANGED</span></dt><dd><p>Metadata routing for <code class="docutils literal notranslate"><span class="pre">sample_weight</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>self<span class="classifier">object</span></dt><dd><p>The updated object.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.to_numpy" title="Link to this definition">#</a></dt>
<dd><p>Selet the numpy scaler. Note that this cannot be called for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The numpy scaler.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>_Scaler_numpy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.to_torch">
<span class="sig-name descname"><span class="pre">to_torch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.to_torch" title="Link to this definition">#</a></dt>
<dd><p>Selet the torch scaler. Note that this cannot be called for conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The torch scaler.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>_Scaler_torch</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.scaler.Scaler.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.scaler.Scaler.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the data using scaler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The data.</p></li>
<li><p><strong>args</strong> (<em>Any</em>) – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.sliding">
<span id="mvpy-estimators-sliding-module"></span><h2>mvpy.estimators.sliding module<a class="headerlink" href="#module-mvpy.estimators.sliding" title="Link to this heading">#</a></h2>
<p>A collection of estimators that allow for sliding other estimators over a dimension of the data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.sliding.</span></span><span class="sig-name descname"><span class="pre">Sliding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">tuple</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Tensor</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements a sliding estimator that allows you to fit estimators iteratively over a set of dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator</strong> (<em>Callable</em><em>, </em><em>sklearn.base.BaseEstimator</em>) – Estimator to use.</p></li>
<li><p><strong>dims</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>tuple</em><em>, </em><em>list</em><em>, </em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em><em>, </em><em>default=-1</em>) – Dimensions to slide over.</p></li>
<li><p><strong>n_jobs</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>None</em><em>]</em><em>, </em><em>default=None</em>) – Number of jobs to run in parallel.</p></li>
<li><p><strong>top</strong> (<em>bool</em><em>, </em><em>default=True</em>) – Is this a top-level estimator?</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Whether to print progress.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.estimators_">
<span class="sig-name descname"><span class="pre">estimators_</span></span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.estimators_" title="Link to this definition">#</a></dt>
<dd><p>List of fitted estimators.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class generally expects that your input data is of shape (n_trials, […], n_channels, […]). Make sure that your data and dimension selection is appropriate for the estimator you wish to fit.
Note also that, when fitting estimators, you _must_ have an equal number of dimensions in X and y. If you do not, please simply pad to the same dimension length.
Finally, be aware that, if you want to use numpy as your backend, you _must_ supply <cite>dims</cite> as a numpy array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sliding</span><span class="p">,</span> <span class="n">Decoder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># trials x searchlights x channels x time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># trials x searchlights x outcomes x time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decoder</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">(</span><span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliding</span> <span class="o">=</span> <span class="n">Sliding</span><span class="p">(</span><span class="n">estimator</span> <span class="o">=</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="c1"># slide over searchlights and time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sliding</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patterns</span> <span class="o">=</span> <span class="n">sliding</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="s1">&#39;pattern_&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">patterns</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([50, 100, 4, 5])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Cloned class.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.sliding.Sliding" title="mvpy.estimators.sliding.Sliding">Sliding</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.collect">
<span class="sig-name descname"><span class="pre">collect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.collect" title="Link to this definition">#</a></dt>
<dd><p>Collect the attribute of the estimators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>attr</strong> (<em>str</em>) – Attribute to collect.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Collected attribute.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.dims">
<span class="sig-name descname"><span class="pre">dims</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(-1,)</span></em><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.dims" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">_ClassifierOvR_torch(alpha=tensor([1.0000e-05,</span> <span class="pre">6.1585e-05,</span> <span class="pre">3.7927e-04,</span> <span class="pre">2.3357e-03,</span> <span class="pre">1.4384e-02,</span> <span class="pre">8.8587e-02,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">5.4556e-01,</span> <span class="pre">3.3598e+00,</span> <span class="pre">2.0691e+01,</span> <span class="pre">1.2743e+02,</span> <span class="pre">7.8476e+02,</span> <span class="pre">4.8329e+03,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">2.9764e+04,</span> <span class="pre">1.8330e+05,</span> <span class="pre">1.1288e+06,</span> <span class="pre">6.9519e+06,</span> <span class="pre">4.2813e+07,</span> <span class="pre">2.6367e+08,</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">1.6238e+09,</span> <span class="pre">1.0000e+10]))</span></em><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.estimator" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Target data.</p></li>
<li><p><strong>*args</strong> – Additional arguments.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.fit_transform">
<span class="sig-name descname"><span class="pre">fit_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.fit_transform" title="Link to this definition">#</a></dt>
<dd><p>Fit and transform the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Target data.</p></li>
<li><p><strong>*args</strong> (<em>Any</em>) – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict the targets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>, </em><em>None</em><em>]</em><em>, </em><em>default=None</em>) – Target data.</p></li>
<li><p><strong>*args</strong> – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Predicted targets.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.predict_proba" title="Link to this definition">#</a></dt>
<dd><p>Predict the probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>, </em><em>None</em><em>]</em><em>, </em><em>default=None</em>) – Target data.</p></li>
<li><p><strong>*args</strong> – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Predicted probabilities.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.top">
<span class="sig-name descname"><span class="pre">top</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.top" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.transform" title="Link to this definition">#</a></dt>
<dd><p>Transform the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – Input data.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>, </em><em>None</em><em>]</em><em>, </em><em>default=None</em>) – Target data.</p></li>
<li><p><strong>*args</strong> (<em>Any</em>) – Additional arguments.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.sliding.Sliding.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#mvpy.estimators.sliding.Sliding.verbose" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators.timedelayed">
<span id="mvpy-estimators-timedelayed-module"></span><h2>mvpy.estimators.timedelayed module<a class="headerlink" href="#module-mvpy.estimators.timedelayed" title="Link to this heading">#</a></h2>
<p>A collection of estimators for TimeDelayed modeling (mTRF + SR).</p>
<dl class="py class">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mvpy.estimators.timedelayed.</span></span><span class="sig-name descname"><span class="pre">TimeDelayed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">tensor([1])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patterns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Implements TimeDelayed regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t_min</strong> (<em>float</em>) – The minimum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p></li>
<li><p><strong>t_max</strong> (<em>float</em>) – The maximum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p></li>
<li><p><strong>fs</strong> (<em>int</em>) – The sampling frequency.</p></li>
<li><p><strong>alphas</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em><em>, </em><em>default=torch.tensor</em><em>(</em><em>[</em><em>1</em><em>]</em><em>)</em>) – The penalties to use for estimation.</p></li>
<li><p><strong>patterns</strong> (<em>bool</em><em>, </em><em>default=False</em>) – Should patterns be estimated?</p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>) – Additional arguments for the estimator.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.alphas">
<span class="sig-name descname"><span class="pre">alphas</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.alphas" title="Link to this definition">#</a></dt>
<dd><p>The penalties to use for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.kwargs" title="Link to this definition">#</a></dt>
<dd><p>Additional arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.patterns">
<span class="sig-name descname"><span class="pre">patterns</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.patterns" title="Link to this definition">#</a></dt>
<dd><p>Should patterns be estimated?</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.t_min">
<span class="sig-name descname"><span class="pre">t_min</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.t_min" title="Link to this definition">#</a></dt>
<dd><p>The minimum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.t_max">
<span class="sig-name descname"><span class="pre">t_max</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.t_max" title="Link to this definition">#</a></dt>
<dd><p>The maximum time delay. Note that positive values indicate X is delayed relative to y. This is unlike MNE’s behaviour.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.fs">
<span class="sig-name descname"><span class="pre">fs</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.fs" title="Link to this definition">#</a></dt>
<dd><p>The sampling frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.window">
<span class="sig-name descname"><span class="pre">window</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.window" title="Link to this definition">#</a></dt>
<dd><p>The window to use for estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.estimator">
<span class="sig-name descname"><span class="pre">estimator</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.estimator" title="Link to this definition">#</a></dt>
<dd><p>The estimator to use.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mvpy.estimators.RidgeCV</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.f_">
<span class="sig-name descname"><span class="pre">f_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.f_" title="Link to this definition">#</a></dt>
<dd><p>The number of output features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.c_">
<span class="sig-name descname"><span class="pre">c_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.c_" title="Link to this definition">#</a></dt>
<dd><p>The number of input features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.w_">
<span class="sig-name descname"><span class="pre">w_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.w_" title="Link to this definition">#</a></dt>
<dd><p>The number of time delays.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.intercept_">
<span class="sig-name descname"><span class="pre">intercept_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.intercept_" title="Link to this definition">#</a></dt>
<dd><p>The intercepts of the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.coef_">
<span class="sig-name descname"><span class="pre">coef_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.coef_" title="Link to this definition">#</a></dt>
<dd><p>The coefficients of the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.pattern_">
<span class="sig-name descname"><span class="pre">pattern_</span></span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.pattern_" title="Link to this definition">#</a></dt>
<dd><p>The patterns of the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>This class allows estimation of either multivariate temporal response functions (mTRF) or stimulus reconstruction (SR) models.</p>
<p>mTRFs are estimated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}r(t,n) = \\sum_\\tau w(\\tau, n) s(t - \\tau) + \\epsilon\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the reconstructed signal at timepoint <span class="math notranslate nohighlight">\(t\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(s(t)\)</span> is the stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(w(\tau, n)\)</span> is the weight at time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, and <span class="math notranslate nohighlight">\(\epsilon\)</span> is the error.</p>
<p>SR models are estimated as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}s(t) = \\sum_n\\sum_\\tau r(t + \\tau, n) g(\\tau, n)\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(s(t)\)</span> is the reconstructed stimulus at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(r(t,n)\)</span> is the neural response at <span class="math notranslate nohighlight">\(t\)</span> and lagged by <span class="math notranslate nohighlight">\(\\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(g(\tau, n)\)</span> is the weight at time delay <span class="math notranslate nohighlight">\(\tau\)</span> for channel <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>For more information on mTRF or SR models, see <a href="#id21"><span class="problematic" id="id13">[1]_</span></a>.</p>
<p>Note that for SR models it is recommended to also pass <cite>patterns=True</cite> to estimate not only the coefficients but also the patterns that were actually used for reconstructing stimuli. For more information, see <a href="#id22"><span class="problematic" id="id14">[2]_</span></a>.</p>
<p class="rubric">References</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Crosse, M.J., Di Liberto, G.M., Bednar, A., &amp; Lalor, E.C. (2016). The multivariate temporal response function (mTRF) toolbox: A MATLAB toolbox for relating neural signals to continuous stimuli. Frontiers in Human Neuroscience, 10, 604. 10.3389/fnhum.2016.00604</p>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Haufe, S., Meinecke, F., Görgen, K., Dähne, S., Haynes, J.D., Blankertz, B., &amp; Bießmann, F. (2014). On the interpretation of weight vectors of linear models in multivariate neuroimaging. NeuroImage, 87, 96-110. 10.1016/j.neuroimage.2013.10.067</p>
</aside>
</aside>
<p class="rubric">Examples</p>
<p>For mTRF estimation, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeDelayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span> <span class="o">=</span> <span class="n">TimeDelayed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">coef_</span>
<span class="go">tensor([[[0.9290, 1.9101, 2.8802, 1.9790, 0.9453]]])</span>
</pre></div>
</div>
<p>For stimulus reconstruction, we can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">mvpy.estimators</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeDelayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ß</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">50</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ß</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:],</span> <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">TimeDelayed</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alphas</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">patterns</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="go">tensor([ 1.3591,  1.2549,  1.5662,  2.3544,  3.3440,  4.3683,  5.4097,  6.4418, 7.4454,  8.4978,  9.5206, 10.5374, 11.5841, 12.6102, 13.6254, 14.6939, 15.6932, 16.7168, 17.7619, 18.8130, 19.8182, 20.8687, 21.8854, 22.9310, 23.9270, 24.9808, 26.0085, 27.0347, 28.0728, 29.0828, 30.1400, 31.1452, 32.1793, 33.2047, 34.2332, 35.2717, 36.2945, 37.3491, 38.3800, 39.3817, 40.3962, 41.4489, 42.4854, 43.4965, 44.5346, 45.5716, 46.7301, 47.2251, 48.4449, 48.8793])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.clone" title="Link to this definition">#</a></dt>
<dd><p>Clone this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The cloned object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#mvpy.estimators.decoder.Decoder" title="mvpy.estimators.decoder.Decoder">Decoder</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.fit" title="Link to this definition">#</a></dt>
<dd><p>Fit the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p></li>
<li><p><strong>y</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The targets.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mvpy.estimators.timedelayed.TimeDelayed.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mvpy.estimators.timedelayed.TimeDelayed.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict from the estimator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>, </em><em>torch.Tensor</em><em>]</em>) – The features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The predictions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[np.ndarray, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-mvpy.estimators">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-mvpy.estimators" title="Link to this heading">#</a></h2>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="mvpy.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">mvpy package</p>
      </div>
    </a>
    <a class="right-next"
       href="mvpy.math.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">mvpy.math package</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.b2b">mvpy.estimators.b2b module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B"><code class="docutils literal notranslate"><span class="pre">B2B</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.alphas"><code class="docutils literal notranslate"><span class="pre">B2B.alphas</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.fit_intercept"><code class="docutils literal notranslate"><span class="pre">B2B.fit_intercept</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.normalise"><code class="docutils literal notranslate"><span class="pre">B2B.normalise</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.alpha_per_target"><code class="docutils literal notranslate"><span class="pre">B2B.alpha_per_target</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.normalise_decoder"><code class="docutils literal notranslate"><span class="pre">B2B.normalise_decoder</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.decoder_"><code class="docutils literal notranslate"><span class="pre">B2B.decoder_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.encoder_"><code class="docutils literal notranslate"><span class="pre">B2B.encoder_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.scaler_"><code class="docutils literal notranslate"><span class="pre">B2B.scaler_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.causal_"><code class="docutils literal notranslate"><span class="pre">B2B.causal_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.pattern_"><code class="docutils literal notranslate"><span class="pre">B2B.pattern_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.clone"><code class="docutils literal notranslate"><span class="pre">B2B.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.fit"><code class="docutils literal notranslate"><span class="pre">B2B.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.b2b.B2B.predict"><code class="docutils literal notranslate"><span class="pre">B2B.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.classifier">mvpy.estimators.classifier module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier"><code class="docutils literal notranslate"><span class="pre">Classifier</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.estimators_"><code class="docutils literal notranslate"><span class="pre">Classifier.estimators_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.estimator_"><code class="docutils literal notranslate"><span class="pre">Classifier.estimator_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.classes_"><code class="docutils literal notranslate"><span class="pre">Classifier.classes_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.intercept_"><code class="docutils literal notranslate"><span class="pre">Classifier.intercept_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.coef_"><code class="docutils literal notranslate"><span class="pre">Classifier.coef_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.pattern_"><code class="docutils literal notranslate"><span class="pre">Classifier.pattern_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.clone"><code class="docutils literal notranslate"><span class="pre">Classifier.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.fit"><code class="docutils literal notranslate"><span class="pre">Classifier.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.predict"><code class="docutils literal notranslate"><span class="pre">Classifier.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.classifier.Classifier.predict_proba"><code class="docutils literal notranslate"><span class="pre">Classifier.predict_proba()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.covariance">mvpy.estimators.covariance module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance"><code class="docutils literal notranslate"><span class="pre">Covariance</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.covariance_"><code class="docutils literal notranslate"><span class="pre">Covariance.covariance_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.precision_"><code class="docutils literal notranslate"><span class="pre">Covariance.precision_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.whitener_"><code class="docutils literal notranslate"><span class="pre">Covariance.whitener_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.shrinkage_"><code class="docutils literal notranslate"><span class="pre">Covariance.shrinkage_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.clone"><code class="docutils literal notranslate"><span class="pre">Covariance.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.fit"><code class="docutils literal notranslate"><span class="pre">Covariance.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.fit_transform"><code class="docutils literal notranslate"><span class="pre">Covariance.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.to_numpy"><code class="docutils literal notranslate"><span class="pre">Covariance.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.to_torch"><code class="docutils literal notranslate"><span class="pre">Covariance.to_torch()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.covariance.Covariance.transform"><code class="docutils literal notranslate"><span class="pre">Covariance.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.decoder">mvpy.estimators.decoder module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder"><code class="docutils literal notranslate"><span class="pre">Decoder</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.estimator_"><code class="docutils literal notranslate"><span class="pre">Decoder.estimator_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.pattern_"><code class="docutils literal notranslate"><span class="pre">Decoder.pattern_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.coef_"><code class="docutils literal notranslate"><span class="pre">Decoder.coef_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.intercept_"><code class="docutils literal notranslate"><span class="pre">Decoder.intercept_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.alpha_"><code class="docutils literal notranslate"><span class="pre">Decoder.alpha_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.clone"><code class="docutils literal notranslate"><span class="pre">Decoder.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.fit"><code class="docutils literal notranslate"><span class="pre">Decoder.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.decoder.Decoder.predict"><code class="docutils literal notranslate"><span class="pre">Decoder.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.encoder">mvpy.estimators.encoder module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder"><code class="docutils literal notranslate"><span class="pre">Encoder</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.alphas"><code class="docutils literal notranslate"><span class="pre">Encoder.alphas</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.kwargs"><code class="docutils literal notranslate"><span class="pre">Encoder.kwargs</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.estimator"><code class="docutils literal notranslate"><span class="pre">Encoder.estimator</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.intercept_"><code class="docutils literal notranslate"><span class="pre">Encoder.intercept_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.coef_"><code class="docutils literal notranslate"><span class="pre">Encoder.coef_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.clone"><code class="docutils literal notranslate"><span class="pre">Encoder.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.fit"><code class="docutils literal notranslate"><span class="pre">Encoder.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.encoder.Encoder.predict"><code class="docutils literal notranslate"><span class="pre">Encoder.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.ridgecv">mvpy.estimators.ridgecv module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV"><code class="docutils literal notranslate"><span class="pre">RidgeCV</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.alpha_"><code class="docutils literal notranslate"><span class="pre">RidgeCV.alpha_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.intercept_"><code class="docutils literal notranslate"><span class="pre">RidgeCV.intercept_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.coef_"><code class="docutils literal notranslate"><span class="pre">RidgeCV.coef_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.clone"><code class="docutils literal notranslate"><span class="pre">RidgeCV.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.fit"><code class="docutils literal notranslate"><span class="pre">RidgeCV.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.ridgecv.RidgeCV.predict"><code class="docutils literal notranslate"><span class="pre">RidgeCV.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.rsa">mvpy.estimators.rsa module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA"><code class="docutils literal notranslate"><span class="pre">RSA</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.rdm_"><code class="docutils literal notranslate"><span class="pre">RSA.rdm_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.cx_"><code class="docutils literal notranslate"><span class="pre">RSA.cx_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.cy_"><code class="docutils literal notranslate"><span class="pre">RSA.cy_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.grouped"><code class="docutils literal notranslate"><span class="pre">RSA.grouped</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.estimator"><code class="docutils literal notranslate"><span class="pre">RSA.estimator</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.n_jobs"><code class="docutils literal notranslate"><span class="pre">RSA.n_jobs</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.verbose"><code class="docutils literal notranslate"><span class="pre">RSA.verbose</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.clone"><code class="docutils literal notranslate"><span class="pre">RSA.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.fit"><code class="docutils literal notranslate"><span class="pre">RSA.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.fit_transform"><code class="docutils literal notranslate"><span class="pre">RSA.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.full_rdm"><code class="docutils literal notranslate"><span class="pre">RSA.full_rdm()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.to_numpy"><code class="docutils literal notranslate"><span class="pre">RSA.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.to_torch"><code class="docutils literal notranslate"><span class="pre">RSA.to_torch()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.rsa.RSA.transform"><code class="docutils literal notranslate"><span class="pre">RSA.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.scaler">mvpy.estimators.scaler module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler"><code class="docutils literal notranslate"><span class="pre">Scaler</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.shape_"><code class="docutils literal notranslate"><span class="pre">Scaler.shape_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.mean_"><code class="docutils literal notranslate"><span class="pre">Scaler.mean_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.var_"><code class="docutils literal notranslate"><span class="pre">Scaler.var_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.scale_"><code class="docutils literal notranslate"><span class="pre">Scaler.scale_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.clone"><code class="docutils literal notranslate"><span class="pre">Scaler.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.copy"><code class="docutils literal notranslate"><span class="pre">Scaler.copy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.fit"><code class="docutils literal notranslate"><span class="pre">Scaler.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.fit_transform"><code class="docutils literal notranslate"><span class="pre">Scaler.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.inverse_transform"><code class="docutils literal notranslate"><span class="pre">Scaler.inverse_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.set_fit_request"><code class="docutils literal notranslate"><span class="pre">Scaler.set_fit_request()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.to_numpy"><code class="docutils literal notranslate"><span class="pre">Scaler.to_numpy()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.to_torch"><code class="docutils literal notranslate"><span class="pre">Scaler.to_torch()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.scaler.Scaler.transform"><code class="docutils literal notranslate"><span class="pre">Scaler.transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.sliding">mvpy.estimators.sliding module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding"><code class="docutils literal notranslate"><span class="pre">Sliding</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.estimators_"><code class="docutils literal notranslate"><span class="pre">Sliding.estimators_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.clone"><code class="docutils literal notranslate"><span class="pre">Sliding.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.collect"><code class="docutils literal notranslate"><span class="pre">Sliding.collect()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.dims"><code class="docutils literal notranslate"><span class="pre">Sliding.dims</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.estimator"><code class="docutils literal notranslate"><span class="pre">Sliding.estimator</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.fit"><code class="docutils literal notranslate"><span class="pre">Sliding.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.fit_transform"><code class="docutils literal notranslate"><span class="pre">Sliding.fit_transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.predict"><code class="docutils literal notranslate"><span class="pre">Sliding.predict()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.predict_proba"><code class="docutils literal notranslate"><span class="pre">Sliding.predict_proba()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.top"><code class="docutils literal notranslate"><span class="pre">Sliding.top</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.transform"><code class="docutils literal notranslate"><span class="pre">Sliding.transform()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.sliding.Sliding.verbose"><code class="docutils literal notranslate"><span class="pre">Sliding.verbose</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators.timedelayed">mvpy.estimators.timedelayed module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed"><code class="docutils literal notranslate"><span class="pre">TimeDelayed</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.alphas"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.alphas</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.kwargs"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.kwargs</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.patterns"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.patterns</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.t_min"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.t_min</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.t_max"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.t_max</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.fs"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.fs</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.window"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.window</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.estimator"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.estimator</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.f_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.f_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.c_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.c_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.w_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.w_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.intercept_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.intercept_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.coef_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.coef_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.pattern_"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.pattern_</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.clone"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.clone()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.fit"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mvpy.estimators.timedelayed.TimeDelayed.predict"><code class="docutils literal notranslate"><span class="pre">TimeDelayed.predict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-mvpy.estimators">Module contents</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/source/mvpy.estimators.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Fabian Schneider.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>